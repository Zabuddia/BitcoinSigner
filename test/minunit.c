#pragma GCC diagnostic ignored "-Wunused-function"

#include "minunit.h"

#include "../bitcoin/ecc/s256field.h"
#include "../bitcoin/ecc/s256point.h"
#include "../bitcoin/ecc/signature.h"
#include "../bitcoin/ecc/privatekey.h"
#include "../bitcoin/tx/tx.h"
#include "../bitcoin/script/op.h"
#include "../bitcoin/script/script.h"

#define S256Field_TEST 1
#define S256Point_TEST 1
#define PrivateKey_TEST 1
#define Signature_TEST 1
#define Helper_TEST 1
#define Tx_TEST 1
#define OP_TEST 1
#define Script_TEST 1
#define Address_TEST 1
#define Other_TEST 1
#define Wallet_TEST 1

//For testing compressed sec and adding points with the same x
#define TEST_N "6d183de4400510e40d4f32da2e72168a5eaa3ee28bf6250923603284adfe55af"
#define TEST_O "434e7a05967edaf81ed577ad1956f5d517cf2370517e88c5c3da215c57bedc3f"
#define TEST_P "bcb185fa69812507e12a8852e6a90a2ae830dc8fae81773a3c25dea2a8411ff0"

//A and B can be a point and X and Y can be a point
#define TEST_A "887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c"
#define TEST_B "61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34"
#define TEST_X "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef12345678"
#define TEST_Y "ffe4951c17e5edff2bb8f4a066b4bee9a962e60e709677d1cb376b38ea0d3bd8"

#define TEST_Z "ec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60"
#define TEST_R "ac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395"
#define TEST_S "68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4"
#define TEST_Z_2 "7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d"
#define TEST_Z_3 "27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0957c2fce9882f715e85d81a6"
#define TEST_Z_4 "e71bfa115715d6fd33796948126f40a8cdd39f187e4afb03896795189fe1423c"

//For testing signature DER format
#define TEST_DER_R "37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6"
#define TEST_DER_S "8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec"

size_t array_length;

uint32_t tests_run = 0;

static char* test_S256Field_eq() {
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, HEX);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, HEX);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_X2);
    mu_assert("Error: S256Field_eq doesn't work", S256Field_eq(test_x1, test_y1) == true);
    S256Field_free(test_x1);
    S256Field_free(test_y1);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    mu_assert("Error: S256Field_eq doesn't work", S256Field_eq(test_x, test_y) == false);
    S256Field_free(test_x);
    S256Field_free(test_y);
    return 0;
}

static char* test_S256Field_ne() {
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, HEX);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, HEX);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_X2);
    mu_assert("Error: S256Field_ne doesn't work", S256Field_ne(test_x1, test_y1) == false);
    S256Field_free(test_x1);
    S256Field_free(test_y1);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    mu_assert("Error: S256Field_ne doesn't work", S256Field_ne(test_x, test_y) == true);
    S256Field_free(test_x);
    S256Field_free(test_y);
    return 0;
}

static char* test_S256Field_add() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "de92540bf693acef0a66b39045627dd98810a4fe4f4436c1a9e52a28fc419621", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_add(test_x, test_y);
    mu_assert("Error: S256Field_add doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_sub() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "dec929d3c6c7d0f0b2f4ca4f77f90006354ad8e16e17471e137653b5282716cf", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_sub(test_x, test_y);
    mu_assert("Error: S256Field_sub doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mul() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "40ff672031c3ee56121ce660b15eb9111b5e97ca27c7beafb50ca874c9f38146", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_mul(test_x, test_y);
    mu_assert("Error: S256Field_mul doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_s_mul() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "d404f0aec405362faa5d716659f90317be0459052290161d04bbec2356c4c30f", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_s_mul(test_x, test_y);
    mu_assert("Error: S256Field_s_mul doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_s_mul_scalar() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "d404f0aec405362faa5d716659f90317be0459052290161d04bbec2356c4c30f", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_s_mul_scalar(test_x, test_Y);
    mu_assert("Error: S256Field_s_mul_scalar doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(test_Y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mul_scalar() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "40ff672031c3ee56121ce660b15eb9111b5e97ca27c7beafb50ca874c9f38146", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_mul_scalar(test_x, test_Y);
    mu_assert("Error: S256Field_mul_scalar doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(test_Y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mod_inv() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "e14a08e686a1504acb1c1f23fa797e0b81476c6a157c6bfb19b55ac3e66e1d7c", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_mod_inv(test_x);
    mu_assert("Error: S256Field_mod_inv doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_s_inv() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "5d80dba49a677f43014d4250ba745be4eb6171982bd6205581fe48428ff08657", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_s_inv(test_x);
    mu_assert("Error: S256Field_s_inv doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_pow() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "4b4f242ad52794aa1a88e2dc56ec8032a91e0f857684e7d7d2c0edc2a38e7c87", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_pow(test_x, test_Y);
    mu_assert("Error: S256Field_pow doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(test_Y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_div() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "00dcad2ac055d0c9a239d0478b1227de5773683cbf67c6629cd7e6fb18ef5e21", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_div(test_x, test_y);
    mu_assert("Error: S256Field_div doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_sqrt() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "3fca07c83ee3aef41802d1f79aed277c58d39d83d48e45d48320d10e3c1efd24", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_sqrt(test_x);
    mu_assert("Error: S256Field_sqrt doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Point_eq() {
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, HEX);
    mpz_t test_Y1;
    mpz_init_set_str(test_Y1, TEST_Y, HEX);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, HEX);
    mpz_t test_Y2;
    mpz_init_set_str(test_Y2, TEST_Y, HEX);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_Y1);
    S256Field* test_x2 = S256Field_init(test_X2);
    S256Field* test_y2 = S256Field_init(test_Y2);
    S256Point* test_p1 = S256Point_init(test_x1, test_y1);
    S256Point* test_p2 = S256Point_init(test_x2, test_y2);
    mu_assert("Error: S256Point_eq doesn't work", S256Point_eq(test_p1, test_p2) == true);

    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, HEX);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, HEX);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    S256Point* test_p3 = S256Point_init(test_a, test_b);
    mu_assert("Error: S256Point_eq doesn't work", S256Point_eq(test_p1, test_p3) == false);
    S256Point_free(test_p1);
    S256Point_free(test_p2);
    S256Point_free(test_p3);
    return 0;
}

static char* test_S256Point_ne() {
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, HEX);
    mpz_t test_Y1;
    mpz_init_set_str(test_Y1, TEST_Y, HEX);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, HEX);
    mpz_t test_Y2;
    mpz_init_set_str(test_Y2, TEST_Y, HEX);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_Y1);
    S256Field* test_x2 = S256Field_init(test_X2);
    S256Field* test_y2 = S256Field_init(test_Y2);
    S256Point* test_p1 = S256Point_init(test_x1, test_y1);
    S256Point* test_p2 = S256Point_init(test_x2, test_y2);
    mu_assert("Error: S256Point_ne doesn't work", S256Point_ne(test_p1, test_p2) == false);

    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, HEX);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, HEX);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    S256Point* test_p3 = S256Point_init(test_a, test_b);
    mu_assert("Error: S256Point_ne doesn't work", S256Point_ne(test_p1, test_p3) == true);
    S256Point_free(test_p1);
    S256Point_free(test_p2);
    S256Point_free(test_p3);
    return 0;
}

static char* test_S256Point_add() {
    //Adding two points with different x and y
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, HEX);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, HEX);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_x;
    mpz_init_set_str(expected_x, "456620086e0791dd93d1b8338cda34fde782c4c0290041099464de364ef3356a", HEX);
    mpz_t expected_y;
    mpz_init_set_str(expected_y, "669b50ea184f441fc623362965e34074856e0cc909b74e291c61f7ddc1f683e2", HEX);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* a = S256Point_init(test_a, test_b);
    S256Point* b = S256Point_init(test_x, test_y);
    S256Point* result = S256Point_add(a, b);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result->x->num, expected_x) == 0);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result->y->num, expected_y) == 0);
    S256Point_free(result);
    S256Point_free(a);
    S256Point_free(b);
    mpz_clear(expected_x);
    mpz_clear(expected_y);
    
    //Adding two points with the same x and different y
    mpz_t test_N1;
    mpz_init_set_str(test_N1, TEST_N, HEX);
    mpz_t test_N2;
    mpz_init_set_str(test_N2, TEST_N, HEX);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, HEX);
    mpz_t test_P;
    mpz_init_set_str(test_P, TEST_P, HEX);
    S256Field* test_n1 = S256Field_init(test_N1);
    S256Field* test_n2 = S256Field_init(test_N2);
    S256Field* test_o = S256Field_init(test_O);
    S256Field* test_p = S256Field_init(test_P);
    S256Point* c = S256Point_init(test_n1, test_o);
    S256Point* d = S256Point_init(test_n2, test_p);
    S256Point* result2 = S256Point_add(c, d);
    mu_assert("Error: S256Point_add doesn't work", result2 == NULL);
    S256Point_free(c);
    S256Point_free(d);

    //Adding two points with the same x and y
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, HEX);
    mpz_t test_Y1;
    mpz_init_set_str(test_Y1, TEST_Y, HEX);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, HEX);
    mpz_t test_Y2;
    mpz_init_set_str(test_Y2, TEST_Y, HEX);
    mpz_t expected_x2;
    mpz_init_set_str(expected_x2, "4c528d70d1702dab37a7e442aa2331ac04884582de6f0fb23285d0ff8b1d9b8f", HEX);
    mpz_t expected_y2;
    mpz_init_set_str(expected_y2, "e6f30b8af8fc994ed48f11ab8a560bb8d1fd7c4474e738c61a2fcc27398cbe25", HEX);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_Y1);
    S256Field* test_x2 = S256Field_init(test_X2);
    S256Field* test_y2 = S256Field_init(test_Y2);
    S256Point* e = S256Point_init(test_x1, test_y1);
    S256Point* f = S256Point_init(test_x2, test_y2);
    S256Point* result3 = S256Point_add(e, f);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result3->x->num, expected_x2) == 0);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result3->y->num, expected_y2) == 0);
    S256Point_free(result3);
    S256Point_free(e);
    S256Point_free(f);
    mpz_clear(expected_x2);
    mpz_clear(expected_y2);
    return 0;
}

static char* test_S256Point_mul() {
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, HEX);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    mpz_t expected_x;
    mpz_init_set_str(expected_x, "d148d491f77e6546f6a2f371727a5dc6e8034fe116eecb405fc4b84feeaed996", HEX);
    mpz_t expected_y;
    mpz_init_set_str(expected_y, "35c349a4272354858ef3be984c31e16d09282c872ba9189a93237f54c56dc5c8", HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* b = S256Point_init(test_x, test_y);
    S256Point* result = S256Point_mul(b, test_A);
    mu_assert("Error: S256Point_mul doesn't work", mpz_cmp(result->x->num, expected_x) == 0);
    mu_assert("Error: S256Point_mul doesn't work", mpz_cmp(result->y->num, expected_y) == 0);
    mpz_clear(test_A);
    mpz_clear(expected_x);
    mpz_clear(expected_y);
    S256Point_free(b);
    S256Point_free(result);

    mpz_t test_E;
    mpz_init_set_str(test_E, "f8c3c567420a3a8d085773412e8e02ecc0f3b959eb1bb6926acfe53b584d9827", HEX);
    mpz_t gx;
    mpz_t gy;
    mpz_init_set_str(gx, GX, HEX);
    mpz_init_set_str(gy, GY, HEX);
    S256Field* x = S256Field_init(gx);
    S256Field* y = S256Field_init(gy);
    S256Point* G = S256Point_init(x, y);
    S256Point* result2 = S256Point_mul(G, test_E);
    mpz_t expected_x2;
    mpz_init_set_str(expected_x2, "c0df4f18b17d4b123e5e8b0baae79cc6fba8f27838d9a8a9efb165bf5e207186", HEX);
    mpz_t expected_y2;
    mpz_init_set_str(expected_y2, "3a7cc43dc5cde30e56495039216a54dd6060ab7543712bc2c546d5006dff26c7", HEX);
    S256Field* expected_x2_field = S256Field_init(expected_x2);
    S256Field* expected_y2_field = S256Field_init(expected_y2);
    S256Point* expected_result2 = S256Point_init(expected_x2_field, expected_y2_field);
    mu_assert("Error: S256Point_mul doesn't work", S256Point_eq(result2, expected_result2) == true);
    S256Point_free(G);
    S256Point_free(result2);
    S256Point_free(expected_result2);
    mpz_clear(test_E);
    return 0;
}

static char* test_S256Point_verify() {
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, HEX);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, HEX);
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, HEX);
    mpz_t test_R;
    mpz_init_set_str(test_R, TEST_R, HEX);
    mpz_t test_S;
    mpz_init_set_str(test_S, TEST_S, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    S256Field* test_r = S256Field_init(test_R);
    S256Field* test_s = S256Field_init(test_S);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    Signature* test_sig = Signature_init(test_r, test_s);
    S256Point* test_p = S256Point_init(test_a, test_b);
    bool result = S256Point_verify(test_p, test_z, test_sig);
    mu_assert("Error: S256Point_verify doesn't work", result == true);
    S256Field_free(test_z);
    Signature_free(test_sig);
    S256Point_free(test_p);

    mpz_t test_Z2;
    mpz_init_set_str(test_Z2, TEST_Z_3, HEX);
    S256Field* test_z2 = S256Field_init(test_Z2);
    uint8_t sec[33] = {0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    uint8_t der[71] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed};
    S256Point* test_p2 = S256Point_parse_sec(sec);
    Signature* test_sig2 = Signature_parse(der);
    bool result2 = S256Point_verify(test_p2, test_z2, test_sig2);
    mu_assert("Error: S256Point_verify doesn't work", result2 == true);
    S256Field_free(test_z2);
    S256Point_free(test_p2);
    Signature_free(test_sig2);
    return 0;
}

static char* test_S256Point_sec_uncompressed() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p = S256Point_init(test_x, test_y);
    uint8_t result[65];
    S256Point_sec_uncompressed(test_p, result);
    uint8_t expected_result[] = {0x04, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78, 0xff, 0xe4, 0x95, 0x1c, 0x17, 0xe5, 0xed, 0xff, 0x2b, 0xb8, 0xf4, 0xa0, 0x66, 0xb4, 0xbe, 0xe9, 0xa9, 0x62, 0xe6, 0x0e, 0x70, 0x96, 0x77, 0xd1, 0xcb, 0x37, 0x6b, 0x38, 0xea, 0x0d, 0x3b, 0xd8};
    mu_assert("Error: S256Point_sec_uncompressed doesn't work", memcmp(result, expected_result, sizeof(expected_result)) == 0);
    S256Point_free(test_p);
    return 0;
}

static char* test_S256Point_sec_compressed() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p_even = S256Point_init(test_x, test_y);
    uint8_t result_even[33];
    S256Point_sec_compressed(test_p_even, result_even);
    mpz_t test_N;
    mpz_init_set_str(test_N, TEST_N, HEX);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, HEX);
    S256Field* test_n = S256Field_init(test_N);
    S256Field* test_o = S256Field_init(test_O);
    S256Point* test_p_odd = S256Point_init(test_n, test_o);
    uint8_t result_odd[33];
    S256Point_sec_compressed(test_p_odd, result_odd);
    uint8_t expected_result_even[] = {0x02, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78};
    uint8_t expected_result_odd[] = {0x03, 0x6d, 0x18, 0x3d, 0xe4, 0x40, 0x05, 0x10, 0xe4, 0x0d, 0x4f, 0x32, 0xda, 0x2e, 0x72, 0x16, 0x8a, 0x5e, 0xaa, 0x3e, 0xe2, 0x8b, 0xf6, 0x25, 0x09, 0x23, 0x60, 0x32, 0x84, 0xad, 0xfe, 0x55, 0xaf};
    mu_assert("Error: S256Point_sec_compressed doesn't work", memcmp(result_even, expected_result_even, sizeof(expected_result_even)) == 0);
    mu_assert("Error: S256Point_sec_compressed doesn't work", memcmp(result_odd, expected_result_odd, sizeof(expected_result_odd)) == 0);
    S256Point_free(test_p_even);
    S256Point_free(test_p_odd);
    return 0;
}

static char* test_S256Point_parse_sec() {
    uint8_t test_compressed_sec_even[] = {0x02, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78};
    S256Point* test_compressed_even_result = S256Point_parse_sec(test_compressed_sec_even);
    uint8_t test_compressed_sec_odd[] = {0x03, 0x6d, 0x18, 0x3d, 0xe4, 0x40, 0x05, 0x10, 0xe4, 0x0d, 0x4f, 0x32, 0xda, 0x2e, 0x72, 0x16, 0x8a, 0x5e, 0xaa, 0x3e, 0xe2, 0x8b, 0xf6, 0x25, 0x09, 0x23, 0x60, 0x32, 0x84, 0xad, 0xfe, 0x55, 0xaf};
    S256Point* test_compressed_odd_result = S256Point_parse_sec(test_compressed_sec_odd);
    uint8_t test_uncompressed_sec[] = {0x04, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78, 0xff, 0xe4, 0x95, 0x1c, 0x17, 0xe5, 0xed, 0xff, 0x2b, 0xb8, 0xf4, 0xa0, 0x66, 0xb4, 0xbe, 0xe9, 0xa9, 0x62, 0xe6, 0x0e, 0x70, 0x96, 0x77, 0xd1, 0xcb, 0x37, 0x6b, 0x38, 0xea, 0x0d, 0x3b, 0xd8};
    S256Point* test_uncompressed_result = S256Point_parse_sec(test_uncompressed_sec);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* expected_result = S256Point_init(test_x, test_y);
    mpz_t test_N;
    mpz_init_set_str(test_N, TEST_N, HEX);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, HEX);
    S256Field* test_n = S256Field_init(test_N);
    S256Field* test_o = S256Field_init(test_O);
    S256Point* expected_odd_result = S256Point_init(test_n, test_o);
    mu_assert("Error: S256Point_parse_sec doesn't work", S256Point_eq(test_uncompressed_result, expected_result) && S256Point_eq(test_compressed_even_result, expected_result) && S256Point_eq(test_compressed_odd_result, expected_odd_result));
    S256Point_free(test_compressed_even_result);
    S256Point_free(test_compressed_odd_result);
    S256Point_free(test_uncompressed_result);
    S256Point_free(expected_result);
    S256Point_free(expected_odd_result);
    return 0;
}

static char* test_S256Point_hash160() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p = S256Point_init(test_x, test_y);
    uint8_t result1[20];
    S256Point_hash160(test_p, result1, false);
    uint8_t result2[20];
    S256Point_hash160(test_p, result2, true);
    uint8_t expected_result1[] = {0xc2, 0x97, 0x66, 0x1a, 0xcd, 0x96, 0x03, 0x71, 0x7c, 0x4e, 0xff, 0xef, 0x62, 0xcc, 0xd5, 0xbd, 0x3f, 0xd0, 0x20, 0x42};
    uint8_t expected_result2[] = {0x96, 0xfe, 0x15, 0xf6, 0xde, 0x2e, 0x40, 0xa8, 0xae, 0x53, 0x50, 0x8b, 0xc6, 0x2e, 0x89, 0xb4, 0x48, 0x13, 0x34, 0x63};
    mu_assert("Error: S256Point_hash160 doesn't work", memcmp(result1, expected_result1, 20) == 0);
    mu_assert("Error: S256Point_hash160 doesn't work", memcmp(result2, expected_result2, 20) == 0);
    S256Point_free(test_p);
    return 0;
}

static char* test_S256Point_address() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, HEX);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, HEX);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p = S256Point_init(test_x, test_y);
    
    uint8_t result1[1024];
    S256Point_address(test_p, result1, false, false);
    char* expected_result1 = "1JjuTbJNnZ7oxmvsMKkwhQcwKZBNB57Dc2";

    uint8_t result2[1024];
    S256Point_address(test_p, result2, true, false);
    char* expected_result2 = "1EmNjxzL2pEeAdkFzJNmU2wzQQHrNFtA9J";

    uint8_t result3[1024];
    S256Point_address(test_p, result3, false, true);
    char* expected_result3 = "myFrkePMbaZ4jtQV4tjKXKqGBYn56ioF2S";

    uint8_t result4[1024];
    S256Point_address(test_p, result4, true, true);
    char* expected_result4 = "muHL325JqqftwkDshsM9HxAKGPtZNLmusA";

    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result1, expected_result1) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result2, expected_result2) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result3, expected_result3) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result4, expected_result4) == 0);

    S256Point_free(test_p);
    return 0;
}

static char* test_Deterministic_k() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    mpz_t secret;
    mpz_init_set_ui(secret, 5000);
    // hash_to_mpz_t((const uint8_t*)"test secret", 11, secret);
    PrivateKey* test_key = PrivateKey_init(secret);
    S256Field* test_k = Deterministic_k(test_key, test_z);
    mpz_t expected_k;
    mpz_init_set_str(expected_k, "1119FF7EEBE4E7AE6C6FF4FFA20852152C76D9ABDBEECEF6CD6AE3E08BD6A520", HEX);
    mu_assert("Error: Deterministic_k doesn't work", mpz_cmp(test_k->num, expected_k) == 0);
    PrivateKey_free(test_key);
    S256Field_free(test_k);
    S256Field_free(test_z);
    mpz_clear(expected_k);
    return 0;
}

static char* test_PrivateKey_sign() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    mpz_t secret;
    // hash_to_mpz_t((const uint8_t*)"test secret", 11, secret);
    mpz_init_set_ui(secret, 5000);
    PrivateKey* test_key = PrivateKey_init(secret);
    Signature* test_sig = PrivateKey_sign(test_key, test_z);
    mpz_t expected_r;
    mpz_init_set_str(expected_r, "C07F2D82B71B02D25824B7207D8519828CC2C5280FD032E8925171F5AAFE4B8B", HEX);
    mpz_t expected_s;
    mpz_init_set_str(expected_s, "3A5A4B502150A3B40E12DB9B060AA5A9EFB52D846E04A0A7E406EEF26F39F04A", HEX);
    mu_assert("Error: PrivateKey_sign doesn't work", mpz_cmp(test_sig->r->num, expected_r) == 0);
    mu_assert("Error: PrivateKey_sign doesn't work", mpz_cmp(test_sig->s->num, expected_s) == 0);
    Signature_free(test_sig);
    PrivateKey_free(test_key);
    S256Field_free(test_z);
    mpz_clear(expected_r);
    mpz_clear(expected_s);
    return 0;
}

static char* test_PrivateKey_wif() {
    mpz_t secret1;
    mpz_init_set_ui(secret1, 5003);
    PrivateKey* test_key1 = PrivateKey_init(secret1);

    mpz_t secret2;
    mpz_init_set_ui(secret2, 33715652388894101);
    PrivateKey* test_key2 = PrivateKey_init(secret2);

    mpz_t secret3;
    mpz_init_set_ui(secret3, 0x54321deadbeef);
    PrivateKey* test_key3 = PrivateKey_init(secret3);

    uint8_t result1[1024];
    PrivateKey_wif(test_key1, result1, true, true);
    char* expected_result1 = "cMahea7zqjxrtgAbB7LSGbcQUr1uX1ojuat9jZodMN8rFTv2sfUK";

    uint8_t result2[1024];
    PrivateKey_wif(test_key2, result2, false, true);
    char* expected_result2 = "91avARGdfge8E4tZfYLoxeJ5sGBdNJQH4kvjpWAxgzczjbCwxic";

    uint8_t result3[1024];
    PrivateKey_wif(test_key3, result3, true, false);
    char* expected_result3 = "KwDiBf89QgGbjEhKnhXJuH7LrciVrZi3qYjgiuQJv1h8Ytr2S53a";

    uint8_t result4[1024];
    PrivateKey_wif(test_key1, result4, false, false);
    char* expected_result4 = "5HpHagT65TZzG1PH3CSu63k8DbpvD8s5ip4nEB3kEsrou4T5tkU";

    mu_assert("Error: PrivateKey_wif doesn't work (result1)", strcmp((char*)result1, expected_result1) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work (result2)", strcmp((char*)result2, expected_result2) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work (result3)", strcmp((char*)result3, expected_result3) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work (result4)", strcmp((char*)result4, expected_result4) == 0);
    PrivateKey_free(test_key1);
    PrivateKey_free(test_key2);
    PrivateKey_free(test_key3);
    return 0;
}

static char* test_Signature_der_length() {
    mpz_t test_R;
    mpz_init_set_str(test_R, TEST_R, HEX);
    mpz_t test_S;
    mpz_init_set_str(test_S, TEST_S, HEX);
    S256Field* test_r = S256Field_init(test_R);
    S256Field* test_s = S256Field_init(test_S);
    Signature* test_sig = Signature_init(test_r, test_s);
    uint8_t result1 = Signature_der_length(test_sig);
    uint8_t expected_result1 = 71;
    mu_assert("Error: Signature_der_length doesn't work", result1 == expected_result1);
    Signature_free(test_sig);

    mpz_t test_R2;
    mpz_init_set_str(test_R2, TEST_DER_R, HEX);
    mpz_t test_S2;
    mpz_init_set_str(test_S2, TEST_DER_S, HEX);
    S256Field* test_r2 = S256Field_init(test_R2);
    S256Field* test_s2 = S256Field_init(test_S2);
    Signature* test_sig2 = Signature_init(test_r2, test_s2);
    uint8_t result2 = Signature_der_length(test_sig2);
    uint8_t expected_result2 = 71;
    mu_assert("Error: Signature_der_length doesn't work", result2 == expected_result2);
    Signature_free(test_sig2);
    return 0;
}

static char* test_Signature_der() {
    mpz_t test_R1;
    mpz_init_set_str(test_R1, TEST_DER_R, HEX);
    mpz_t test_S1;
    mpz_init_set_str(test_S1, TEST_DER_S, HEX);
    mpz_t test_R2;
    mpz_init_set_str(test_R2, TEST_R, HEX);
    mpz_t test_S2;
    mpz_init_set_str(test_S2, TEST_S, HEX);
    S256Field* test_r1 = S256Field_init(test_R1);
    S256Field* test_s1 = S256Field_init(test_S1);
    Signature* test_sig1 = Signature_init(test_r1, test_s1);
    S256Field* test_r2 = S256Field_init(test_R2);
    S256Field* test_s2 = S256Field_init(test_S2);
    Signature* test_sig2 = Signature_init(test_r2, test_s2);

    uint8_t result1[71] = {0};
    uint8_t result2[71] = {0};
    Signature_der(test_sig1, result1);
    Signature_der(test_sig2, result2);
    uint8_t expected_result1[71] = {0x30, 0x45, 0x02, 0x20, 0x37, 0x20, 0x6a, 0x06, 0x10, 0x99, 0x5c, 0x58, 0x07, 0x49, 0x99, 0xcb, 0x97, 0x67, 0xb8, 0x7a, 0xf4, 0xc4, 0x97, 0x8d, 0xb6, 0x8c, 0x06, 0xe8, 0xe6, 0xe8, 0x1d, 0x28, 0x20, 0x47, 0xa7, 0xc6, 0x02, 0x21, 0x00, 0x8c, 0xa6, 0x37, 0x59, 0xc1, 0x15, 0x7e, 0xbe, 0xae, 0xc0, 0xd0, 0x3c, 0xec, 0xca, 0x11, 0x9f, 0xc9, 0xa7, 0x5b, 0xf8, 0xe6, 0xd0, 0xfa, 0x65, 0xc8, 0x41, 0xc8, 0xe2, 0x73, 0x8c, 0xda, 0xec};
    uint8_t expected_result2[71] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xac, 0x8d, 0x1c, 0x87, 0xe5, 0x1d, 0x0d, 0x44, 0x1b, 0xe8, 0xb3, 0xdd, 0x5b, 0x05, 0xc8, 0x79, 0x5b, 0x48, 0x87, 0x5d, 0xff, 0xe0, 0x0b, 0x7f, 0xfc, 0xfa, 0xc2, 0x30, 0x10, 0xd3, 0xa3, 0x95, 0x02, 0x20, 0x06, 0x83, 0x42, 0xce, 0xff, 0x89, 0x35, 0xed, 0xed, 0xd1, 0x02, 0xdd, 0x87, 0x6f, 0xfd, 0x6b, 0xa7, 0x2d, 0x6a, 0x42, 0x7a, 0x3e, 0xdb, 0x13, 0xd2, 0x6e, 0xb0, 0x78, 0x1c, 0xb4, 0x23, 0xc4};
    mu_assert("Error: Signature_der doesn't work (result 1)", memcmp(result1, expected_result1, 71) == 0);
    mu_assert("Error: Signature_der doesn't work (result 2)", memcmp(result2, expected_result2, 71) == 0);
    Signature_free(test_sig1);
    Signature_free(test_sig2);

    uint8_t raw_tx[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* transaction = Tx_parse(raw_tx, false);
    uint8_t z_raw[32] = {0};
    sig_hash(transaction, 0, z_raw, NULL);
    char z_hex[65];
    byte_array_to_hex_string(z_raw, 32, z_hex);
    mpz_t Z;
    mpz_init_set_str(Z, z_hex, HEX);
    S256Field* z = S256Field_init(Z);
    mpz_t secret;
    mpz_init_set_ui(secret, 8675309);
    PrivateKey* private_key = PrivateKey_init(secret);
    uint8_t wif[52] = {0};
    PrivateKey_wif(private_key, wif, true, false);
    Signature* signature = PrivateKey_sign(private_key, z);
    uint8_t der[70] = {0};
    Signature_der(signature, der);
    uint8_t expected_result3[70] = {0x30, 0x44, 0x02, 0x20, 0x7d, 0xb2, 0x40, 0x2a, 0x33, 0x11, 0xa3, 0xb8, 0x45, 0xb0, 0x38, 0x88, 0x5e, 0x3d, 0xd8, 0x89, 0xc0, 0x81, 0x26, 0xa8, 0x57, 0x0f, 0x26, 0xa8, 0x44, 0xe3, 0xe4, 0x04, 0x9c, 0x48, 0x2a, 0x11, 0x02, 0x20, 0x10, 0x17, 0x8c, 0xdc, 0xa4, 0x12, 0x9e, 0xac, 0xbe, 0xab, 0x7c, 0x44, 0x64, 0x8b, 0xf5, 0xac, 0x1f, 0x9c, 0xac, 0x21, 0x7c, 0xd6, 0x09, 0xd2, 0x16, 0xec, 0x2e, 0xbc, 0x8d, 0x24, 0x2c, 0x0a};
    mu_assert("Error: Signature_der doesn't work (result 3)", memcmp(der, expected_result3, 70) == 0);
    Tx_free(transaction);
    S256Field_free(z);
    PrivateKey_free(private_key);
    Signature_free(signature);
    return 0;
}

static char* test_Signature_parse() {
    mpz_t test_R1;
    mpz_init_set_str(test_R1, TEST_DER_R, HEX);
    mpz_t test_S1;
    mpz_init_set_str(test_S1, TEST_DER_S, HEX);
    mpz_t test_R2;
    mpz_init_set_str(test_R2, TEST_R, HEX);
    mpz_t test_S2;
    mpz_init_set_str(test_S2, TEST_S, HEX);
    uint8_t raw_sig_1[] = {0x30, 0x45, 0x02, 0x20, 0x37, 0x20, 0x6a, 0x06, 0x10, 0x99, 0x5c, 0x58, 0x07, 0x49, 0x99, 0xcb, 0x97, 0x67, 0xb8, 0x7a, 0xf4, 0xc4, 0x97, 0x8d, 0xb6, 0x8c, 0x06, 0xe8, 0xe6, 0xe8, 0x1d, 0x28, 0x20, 0x47, 0xa7, 0xc6, 0x02, 0x21, 0x00, 0x8c, 0xa6, 0x37, 0x59, 0xc1, 0x15, 0x7e, 0xbe, 0xae, 0xc0, 0xd0, 0x3c, 0xec, 0xca, 0x11, 0x9f, 0xc9, 0xa7, 0x5b, 0xf8, 0xe6, 0xd0, 0xfa, 0x65, 0xc8, 0x41, 0xc8, 0xe2, 0x73, 0x8c, 0xda, 0xec};
    uint8_t raw_sig_2[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xac, 0x8d, 0x1c, 0x87, 0xe5, 0x1d, 0x0d, 0x44, 0x1b, 0xe8, 0xb3, 0xdd, 0x5b, 0x05, 0xc8, 0x79, 0x5b, 0x48, 0x87, 0x5d, 0xff, 0xe0, 0x0b, 0x7f, 0xfc, 0xfa, 0xc2, 0x30, 0x10, 0xd3, 0xa3, 0x95, 0x02, 0x20, 0x06, 0x83, 0x42, 0xce, 0xff, 0x89, 0x35, 0xed, 0xed, 0xd1, 0x02, 0xdd, 0x87, 0x6f, 0xfd, 0x6b, 0xa7, 0x2d, 0x6a, 0x42, 0x7a, 0x3e, 0xdb, 0x13, 0xd2, 0x6e, 0xb0, 0x78, 0x1c, 0xb4, 0x23, 0xc4};
    Signature* sig_1 = Signature_parse(raw_sig_1);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_1->r->num, test_R1) == 0);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_1->s->num, test_S1) == 0);
    Signature* sig_2 = Signature_parse(raw_sig_2);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_2->r->num, test_R2) == 0);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_2->s->num, test_S2) == 0);
    Signature_free(sig_1);
    Signature_free(sig_2);
    mpz_clear(test_R1);
    mpz_clear(test_S1);
    mpz_clear(test_R2);
    mpz_clear(test_S2);
    return 0;
}

static char* test_sha1() {
    uint8_t test1[] = {0x61, 0x62, 0x63};
    uint8_t result1[20];
    sha1(test1, 3, result1);
    uint8_t expected_result1[] = {0xa9, 0x99, 0x3e, 0x36, 0x47, 0x06, 0x81, 0x6a, 0xba, 0x3e, 0x25, 0x71, 0x78, 0x50, 0xc2, 0x6c, 0x9c, 0xd0, 0xd8, 0x9d};
    mu_assert("Error: sha1 doesn't work", memcmp(result1, expected_result1, 20) == 0);
    uint8_t test2[] = {0x41, 0x42, 0x43};
    uint8_t result2[20];
    sha1(test2, 3, result2);
    uint8_t expected_result2[] = {0x3c, 0x01, 0xbd, 0xbb, 0x26, 0xf3, 0x58, 0xba, 0xb2, 0x7f, 0x26, 0x79, 0x24, 0xaa, 0x2c, 0x9a, 0x03, 0xfc, 0xfd, 0xb8};
    mu_assert("Error: sha1 doesn't work", memcmp(result2, expected_result2, 20) == 0);
    return 0;
}

static char* test_sha256() {
    uint8_t test1[] = {0x61, 0x62, 0x63};
    uint8_t result1[32];
    sha256(test1, 3, result1);
    uint8_t expected_result1[] = {0xba, 0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea, 0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23, 0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, 0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad};
    mu_assert("Error: sha256 doesn't work", memcmp(result1, expected_result1, 32) == 0);
    uint8_t test2[] = {0x41, 0x42, 0x43};
    uint8_t result2[32];
    sha256(test2, 3, result2);
    uint8_t expected_result2[] = {0xb5, 0xd4, 0x04, 0x5c, 0x3f, 0x46, 0x6f, 0xa9, 0x1f, 0xe2, 0xcc, 0x6a, 0xbe, 0x79, 0x23, 0x2a, 0x1a, 0x57, 0xcd, 0xf1, 0x04, 0xf7, 0xa2, 0x6e, 0x71, 0x6e, 0x0a, 0x1e, 0x27, 0x89, 0xdf, 0x78};
    mu_assert("Error: sha256 doesn't work", memcmp(result2, expected_result2, 32) == 0);
    return 0;
}

static char* test_ripemd160() {
    uint8_t test1[] = {0x61, 0x62, 0x63};
    uint8_t result1[20];
    ripemd160(test1, 3, result1);
    uint8_t expected_result1[] = {0x8e, 0xb2, 0x08, 0xf7, 0xe0, 0x5d, 0x98, 0x7a, 0x9b, 0x04, 0x4a, 0x8e, 0x98, 0xc6, 0xb0, 0x87, 0xf1, 0x5a, 0x0b, 0xfc};
    mu_assert("Error: ripemd160 doesn't work", memcmp(result1, expected_result1, 20) == 0);
    uint8_t test2[] = {0x41, 0x42, 0x43};
    uint8_t result2[20];
    ripemd160(test2, 3, result2);
    uint8_t expected_result2[] = {0xdf, 0x62, 0xd4, 0x00, 0xe5, 0x1d, 0x35, 0x82, 0xd5, 0x3c, 0x2d, 0x89, 0xcf, 0xeb, 0x6e, 0x10, 0xd3, 0x2a, 0x3c, 0xa6};
    mu_assert("Error: ripemd160 doesn't work", memcmp(result2, expected_result2, 20) == 0);
    return 0;
}

static char* test_hash160() {
    uint8_t test[11] = "hello world";
    uint8_t result[20];
    hash160(test, 11, result);
    uint8_t expected_result[] = {0xd7, 0xd5, 0xee, 0x78, 0x24, 0xff, 0x93, 0xf9, 0x4c, 0x30, 0x55, 0xaf, 0x93, 0x82, 0xc8, 0x6c, 0x68, 0xb5, 0xca, 0x92};
    mu_assert("Error: hash160 doesn't work", memcmp(result, expected_result, 20) == 0);
    uint8_t test1[] = {0x61, 0x62, 0x63};
    uint8_t result1[20];
    hash160(test1, 3, result1);
    uint8_t expected_result1[] = {0xbb, 0x1b, 0xe9, 0x8c, 0x14, 0x24, 0x44, 0xd7, 0xa5, 0x6a, 0xa3, 0x98, 0x1c, 0x39, 0x42, 0xa9, 0x78, 0xe4, 0xdc, 0x33};
    mu_assert("Error: hash160 doesn't work", memcmp(result1, expected_result1, 20) == 0);
    uint8_t test2[] = {0x41, 0x42, 0x43};
    uint8_t result2[20];
    hash160(test2, 3, result2);
    uint8_t expected_result2[] = {0xf8, 0x2a, 0xaa, 0x97, 0x04, 0x23, 0x82, 0xb2, 0xd7, 0x57, 0x13, 0xbc, 0xe7, 0x52, 0x09, 0x29, 0xd1, 0x19, 0x40, 0x08};
    mu_assert("Error: hash160 doesn't work", memcmp(result2, expected_result2, 20) == 0);
    return 0;
}

static char* test_hash256() {
    uint8_t modified_tx[148] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xa8, 0x02, 0xfc, 0x56, 0xc7, 0x04, 0xce, 0x87, 0xc4, 0x2d, 0x7c, 0x92, 0xeb, 0x75, 0xe7, 0x89, 0x6b, 0xdc, 0x41, 0xae, 0x88, 0xac, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00};
    uint8_t result[32] = {0};
    uint8_t expected_result[32] = {0x27, 0xe0, 0xc5, 0x99, 0x4d, 0xec, 0x78, 0x24, 0xe5, 0x6d, 0xec, 0x6b, 0x2f, 0xcb, 0x34, 0x2e, 0xb7, 0xcd, 0xb0, 0xd0, 0x95, 0x7c, 0x2f, 0xce, 0x98, 0x82, 0xf7, 0x15, 0xe8, 0x5d, 0x81, 0xa6};
    hash256(modified_tx, 148, result);
    mu_assert("Error: hash256 doesn't work", memcmp(result, expected_result, 32) == 0);
    uint8_t test1[] = {0x61, 0x62, 0x63};
    uint8_t result1[32];
    hash256(test1, 3, result1);
    uint8_t expected_result1[] = {0x4f, 0x8b, 0x42, 0xc2, 0x2d, 0xd3, 0x72, 0x9b, 0x51, 0x9b, 0xa6, 0xf6, 0x8d, 0x2d, 0xa7, 0xcc, 0x5b, 0x2d, 0x60, 0x6d, 0x05, 0xda, 0xed, 0x5a, 0xd5, 0x12, 0x8c, 0xc0, 0x3e, 0x6c, 0x63, 0x58};
    mu_assert("Error: hash256 doesn't work", memcmp(result1, expected_result1, 32) == 0);
    uint8_t test2[] = {0x41, 0x42, 0x43};
    uint8_t result2[32];
    hash256(test2, 3, result2);
    uint8_t expected_result2[] = {0x3a, 0x00, 0xe4, 0x4e, 0x7b, 0xb6, 0x9f, 0x11, 0xd8, 0x68, 0x66, 0xf1, 0xad, 0xfa, 0x75, 0xf5, 0xeb, 0x36, 0xc9, 0x44, 0xb2, 0x2a, 0x47, 0xfd, 0x98, 0x86, 0x86, 0x34, 0xf0, 0x5b, 0x52, 0x35};
    mu_assert("Error: hash256 doesn't work", memcmp(result2, expected_result2, 32) == 0);
    return 0;
}

static char* test_hash_to_mpz_t() {
    mpz_t result1;
    hash_to_mpz_t((const uint8_t*)"test", 4, result1);
    mpz_t expected_result1;
    mpz_init_set_str(expected_result1, "f40922e8c5bd1984f8746cfaf77e7f9529782652d235dbbcb8d970fd495a4d95", HEX);
    mu_assert("Error: hash_to_mpz_t doesn't work", mpz_cmp(result1, expected_result1) == 0);
    mpz_t result2;
    hash_to_mpz_t((const uint8_t*)"test2", 5, result2);
    mpz_t expected_result2;
    mpz_init_set_str(expected_result2, "aec3d6b568182eef6016c2090718d1b66efe08bbaf442aa5d444d36078292b8", HEX);
    mu_assert("Error: hash_to_mpz_t doesn't work", mpz_cmp(result2, expected_result2) == 0);
    mpz_clear(expected_result1);
    mpz_clear(expected_result2);
    mpz_clear(result1);
    mpz_clear(result2);
    return 0;
}

static char* test_mpz_to_bytes() {
    mpz_t test1;
    mpz_init_set_str(test1, "5e2e9d7b9e4c7b3f8f5a3f3c7f7b6d9f", HEX);
    uint8_t result1[16] = {0};
    mpz_to_bytes(test1, result1, 16);
    uint8_t expected_result1[] = {0x5e, 0x2e, 0x9d, 0x7b, 0x9e, 0x4c, 0x7b, 0x3f, 0x8f, 0x5a, 0x3f, 0x3c, 0x7f, 0x7b, 0x6d, 0x9f};
    mu_assert("Error: mpz_to_bytes doesn't work", memcmp(result1, expected_result1, 16) == 0);
    mpz_t test2;
    mpz_init_set_str(test2, "8f3f9f5f3f5f3f5f3f5f3f5f3f5f3f5f", HEX);
    uint8_t result2[16];
    mpz_to_bytes(test2, result2, 16);
    uint8_t expected_result2[] = {0x8f, 0x3f, 0x9f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f};
    mu_assert("Error: mpz_to_bytes doesn't work", memcmp(result2, expected_result2, 16) == 0);
    mpz_clear(test1);
    mpz_clear(test2);
    return 0;
}

static char* test_mpz_to_32bytes() {
    mpz_t test1;
    mpz_init_set_str(test1, "5e2e9d7b9e4c7b3f8f5a3f3c7f7b6d9f", HEX);
    uint8_t result1[32];
    mpz_to_32bytes(test1, result1);
    uint8_t expected_result1[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5e, 0x2e, 0x9d, 0x7b, 0x9e, 0x4c, 0x7b, 0x3f, 0x8f, 0x5a, 0x3f, 0x3c, 0x7f, 0x7b, 0x6d, 0x9f};
    mu_assert("Error: mpz_to_32bytes doesn't work", memcmp(result1, expected_result1, 32) == 0);
    mpz_t test2;
    mpz_init_set_str(test2, "8f3f9f5f3f5f3f5f3f5f3f5f3f5f3f5f", HEX);
    uint8_t result2[32];
    mpz_to_32bytes(test2, result2);
    uint8_t expected_result2[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8f, 0x3f, 0x9f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f, 0x3f, 0x5f};
    mu_assert("Error: mpz_to_32bytes doesn't work", memcmp(result2, expected_result2, 32) == 0);
    mpz_clear(test1);
    mpz_clear(test2);
    return 0;
}

static char* test_compute_hmac_sha256() {
    uint8_t key[] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a};
    uint8_t data[] = {0x61, 0x62, 0x63};
    uint8_t result[32];
    uint32_t size = 32;
    compute_hmac_sha256(key, sizeof(key), data, sizeof(data), result, &size);
    uint8_t expected_result[] = {0x8c, 0xf6, 0x5e, 0x5b, 0x29, 0x1f, 0x88, 0x34, 0x7a, 0x87, 0x5f, 0x80, 0xe0, 0xa3, 0x0c, 0xcd, 0x62, 0x1c, 0xff, 0xb0, 0x7c, 0x61, 0xad, 0x3b, 0x00, 0x1b, 0x0a, 0x74, 0x6a, 0x62, 0x05, 0xce};
    mu_assert("Error: computer_hmac_sha256 doesn't work", memcmp(result, expected_result, 32) == 0);
    return 0;
}

static char* test_encode_base58() {
    const char test1[] = {0x7c, 0x07, 0x6f, 0xf3, 0x16, 0x69, 0x2a, 0x3d, 0x7e, 0xb3, 0xc3, 0xbb, 0x0f, 0x8b, 0x14, 0x88, 0xcf, 0x72, 0xe1, 0xaf, 0xcd, 0x92, 0x9e, 0x29, 0x30, 0x70, 0x32, 0x99, 0x7a, 0x83, 0x8a, 0x3d};
    uint8_t result1[45];
    uint32_t size = 45;
    encode_base58(result1, &size, test1, sizeof(test1));
    char* expected_result1 = "9MA8fRQrT4u8Zj8ZRd6MAiiyaxb2Y1CMpvVkHQu5hVM6";
    mu_assert("Error: encode_base58 doesn't work (result 1)", strcmp((char*)result1, expected_result1) == 0);
    const char test2[] = {0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c};
    uint8_t result2[44];
    encode_base58(result2, &size, test2, sizeof(test2));
    char* expected_result2 = "4fE3H2E6XMp4SsxtwinF7w9a34ooUrwWe4WsW1458Pd";
    mu_assert("Error: encode_base58 doesn't work (result 2)", strcmp((char*)result2, expected_result2) == 0);
    const char test3[] = {0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6};
    uint8_t result3[45];
    encode_base58(result3, &size, test3, sizeof(test3));
    char* expected_result3 = "EQJsjkd6JaGwxrjEhfeqPenqHwrBmPQZjJGNSCHBkcF7";
    mu_assert("Error: encode_base58 doesn't work (result 3)", strcmp((char*)result3, expected_result3) == 0);
    return 0;
}

static char* test_decode_base58() {
    const char* string1 = "1CgvQuEBc7FU1QVWDL3cMF5bG5w3QRKsYt";
    uint8_t result1[25] = {0};
    decode_base58(string1, result1);
    uint8_t expected_result1[20] = {0x80, 0x36, 0x31, 0x39, 0xc8, 0x40, 0xaa, 0xeb, 0xe2, 0xcd, 0x2e, 0x2c, 0x35, 0x5e, 0x25, 0x9f, 0x43, 0x46, 0x1f, 0x6c};
    mu_assert("Error: decode_base58 doesn't work", memcmp(result1, expected_result1, 20) == 0);
    const char* string2 = "1HqC6HfkvV8rXsAiKYaW6bFEoU4U8a17rH";
    uint8_t result2[25] = {0};
    decode_base58(string2, result2);
    uint8_t expected_result2[20] = {0xb8, 0x9f, 0x3c, 0xb5, 0x55, 0x5f, 0xa0, 0xdb, 0xb5, 0xe1, 0x43, 0x9b, 0x05, 0x07, 0x95, 0xf3, 0x1d, 0x10, 0x3b, 0x2e};
    mu_assert("Error: decode_base58 doesn't work", memcmp(result2, expected_result2, 20) == 0);
    const char* string = "mnrVtF8DWjMu839VW3rBfgYaAfKk8983Xf";
    uint8_t result[20] = {0};
    decode_base58(string, result);
    uint8_t expected_result[25] = {0x50, 0x7b, 0x27, 0x41, 0x1c, 0xcf, 0x7f, 0x16, 0xf1, 0x02, 0x97, 0xde, 0x6c, 0xef, 0x3f, 0x29, 0x16, 0x23, 0xed, 0xdf};
    mu_assert("Error: decode_base58 doesn't work", memcmp(result, expected_result, 20) == 0);
    return 0;
}

static char* test_encode_base58_checksum_address() {
    uint8_t test1[20] = {0x00, 0x14, 0x6e, 0x9f, 0x6a, 0x9b, 0x8f, 0x0f, 0x4e, 0x5d, 0x6a, 0x57, 0x78, 0x6e, 0x06, 0x6e, 0x6c, 0x5c, 0x20, 0x15};
    uint8_t result1[1024];
    uint32_t size = 1024;
    encode_base58_checksum_address(result1, &size, test1, 20);
    char* expected_result1 = "12s333Ck7wghXm8JLH6T3PZJQpQ3EW7pj1";
    mu_assert("Error: encode_base58_checksum_address doesn't work (result 1)", strcmp((char*)result1, expected_result1) == 0);
    uint8_t test2[20] = {0x6f, 0x2a, 0x2c, 0x9a, 0x52, 0x63, 0x87, 0x04, 0xf4, 0x40, 0xa8, 0x11, 0x1e, 0x5b, 0xf5, 0x4d, 0xdd, 0x9a, 0x21, 0xd5};
    uint8_t result2[1024];
    encode_base58_checksum_address(result2, &size, test2, 20);
    char* expected_result2 = "mjMx7AmEZzGsfdAhctmobRiMZD2x8QPPiX";
    mu_assert("Error: encode_base58_checksum_address doesn't work (result 2)", strcmp((char*)result2, expected_result2) == 0);
    return 0;
}

static char* test_encode_base58_checksum_wif_uncompressed() {
    uint8_t test1[20] = {0x80, 0x14, 0x6e, 0x9f, 0x6a, 0x9b, 0x8f, 0x0f, 0x4e, 0x5d, 0x6a, 0x57, 0x78, 0x6e, 0x06, 0x6e, 0x6c, 0x5c, 0x20, 0x15};
    uint8_t result1[1024];
    uint32_t size = 1024;
    encode_base58_checksum_wif_uncompressed(result1, &size, test1, 20);
    char* expected_result1 = "5HyHVXLF8MBxDaG4DBfhGuuFgJNJ7ZPYrfPu2Sc42q9HEEe3Yoy";
    mu_assert("Error: encode_base58_checksum_wif_uncompressed doesn't work (result 1)", strcmp((char*)result1, expected_result1) == 0);
    uint8_t test2[20] = {0xef, 0x2a, 0x2c, 0x9a, 0x52, 0x63, 0x87, 0x04, 0xf4, 0x40, 0xa8, 0x11, 0x1e, 0x5b, 0xf5, 0x4d, 0xdd, 0x9a, 0x21, 0xd5};
    uint8_t result2[1024];
    encode_base58_checksum_wif_uncompressed(result2, &size, test2, 20);
    char* expected_result2 = "91uVSty5YT7MndWQ6LVX8cDh5kGApCZeEyySFfw5wTnfR8r3BDZ";
    mu_assert("Error: encode_base58_checksum_wif_uncompressed doesn't work (result 2)", strcmp((char*)result2, expected_result2) == 0);
    return 0;
}

static char* test_encode_base58_checksum_wif_compressed() {
    uint8_t test1[21] = {0x80, 0x14, 0x6e, 0x9f, 0x6a, 0x9b, 0x8f, 0x0f, 0x4e, 0x5d, 0x6a, 0x57, 0x78, 0x6e, 0x06, 0x6e, 0x6c, 0x5c, 0x20, 0x15, 0x01};
    uint8_t result1[1024];
    uint32_t size = 1024;
    encode_base58_checksum_wif_compressed(result1, &size, test1, 21);
    char* expected_result1 = "KwuRntswMS7LiVoTAn5nmEVdnTevcWFHWiVx5jgdAbTQDD8C76Uo";
    mu_assert("Error: encode_base58_checksum_wif_compressed doesn't work (result 1)", strcmp((char*)result1, expected_result1) == 0);
    uint8_t test2[21] = {0xef, 0x2a, 0x2c, 0x9a, 0x52, 0x63, 0x87, 0x04, 0xf4, 0x40, 0xa8, 0x11, 0x1e, 0x5b, 0xf5, 0x4d, 0xdd, 0x9a, 0x21, 0xd5, 0x01};
    uint8_t result2[1024];
    encode_base58_checksum_wif_compressed(result2, &size, test2, 21);
    char* expected_result2 = "cNzgZJNX3pF4kQ8kvZ2szaT1uwwnpeJSoYxL6k1ZnCewSEHM6aes";
    mu_assert("Error: encode_base58_checksum_wif_compressed doesn't work (result 2)", strcmp((char*)result2, expected_result2) == 0);
    return 0;
}

static char* test_little_endian_to_int() {
    uint8_t test1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test1, 4) == 1);
    uint8_t test2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test2, 4) == 16843009);
    uint8_t test3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test3, 3) == 16777215);
    return 0;
}

static char* test_little_endian_to_long() {
    uint8_t test1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test1, 4) == 1);
    uint8_t test2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test2, 4) == 16843009);
    uint8_t test3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test3, 3) == 16777215);
    uint8_t test4[] = {0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test4, 8) == 18005558675309);
    return 0;
}

static char* test_int_to_little_endian() {
    uint8_t result1[4];
    int_to_little_endian(1, result1, 4);
    uint8_t expected_result1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    uint8_t result2[4];
    int_to_little_endian(16843009, result2, 4);
    uint8_t expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    uint8_t result3[3];
    int_to_little_endian(16777215, result3, 3);
    uint8_t expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    return 0;
}

static char* test_long_to_little_endian() {
    uint8_t result1[4];
    long_to_little_endian(1, result1, 4);
    uint8_t expected_result1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    uint8_t result2[4];
    long_to_little_endian(16843009, result2, 4);
    uint8_t expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    uint8_t result3[3];
    long_to_little_endian(16777215, result3, 3);
    uint8_t expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    uint8_t result4[8];
    long_to_little_endian(18005558675309, result4, 8);
    uint8_t expected_result4[] = {0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result4, expected_result4, sizeof(expected_result4)) == 0);
    return 0;
}

static char* test_read_varint() {
    uint8_t data1[] = {0x64};
    uint64_t num1 = read_varint(data1);
    mu_assert("Error: read_varint doesn't work", num1 == 100);
    uint8_t data2[] = {0xfd, 0xff, 0x00};
    uint64_t num2 = read_varint(data2);
    mu_assert("Error: read_varint doesn't work", num2 == 255);
    uint8_t data3[] = {0xfd, 0x2b, 0x02};
    uint64_t num3 = read_varint(data3);
    mu_assert("Error: read_varint doesn't work", num3 == 555);
    uint8_t data4[] = {0xfe, 0x7f, 0x11, 0x01, 0x00};
    uint64_t num4 = read_varint(data4);
    mu_assert("Error: read_varint doesn't work", num4 == 70015);
    uint8_t data5[] = {0xff, 0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    uint64_t num5 = read_varint(data5);
    mu_assert("Error: read_varint doesn't work", num5 == 18005558675309);
    return 0;
}

static char* test_encode_varint() {
    uint64_t num1 = 100;
    uint8_t result1[1024];
    encode_varint(result1, num1);
    uint8_t expected_result1[] = {0x64};
    mu_assert("Error: encode_varint doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    uint64_t num2 = 255;
    uint8_t result2[1024];
    encode_varint(result2, num2);
    uint8_t expected_result2[] = {0xfd, 0xff, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    uint64_t num3 = 555;
    uint8_t result3[1024];
    encode_varint(result3, num3);
    uint8_t expected_result3[] = {0xfd, 0x2b, 0x02};
    mu_assert("Error: encode_varint doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    uint64_t num4 = 70015;
    uint8_t result4[1024];
    encode_varint(result4, num4);
    uint8_t expected_result4[] = {0xfe, 0x7f, 0x11, 0x01, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result4, expected_result4, sizeof(expected_result4)) == 0);
    uint64_t num5 = 18005558675309;
    uint8_t result5[1024];
    encode_varint(result5, num5);
    uint8_t expected_result5[] = {0xff, 0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result5, expected_result5, sizeof(expected_result5)) == 0);
    return 0;
}

static char* test_little_endian_to_big_endian() {
    uint8_t test1[] = {0x01, 0x00, 0x00, 0x00};
    little_endian_to_big_endian(test1, 4);
    uint8_t expected_result1[] = {0x00, 0x00, 0x00, 0x01};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test1, expected_result1, sizeof(expected_result1)) == 0);
    uint8_t test2[] = {0x01, 0x01, 0x01, 0x01};
    little_endian_to_big_endian(test2, 4);
    uint8_t expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test2, expected_result2, sizeof(expected_result2)) == 0);
    uint8_t test3[] = {0xff, 0xff, 0xff};
    little_endian_to_big_endian(test3, 3);
    uint8_t expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test3, expected_result3, sizeof(expected_result3)) == 0);
    uint8_t test4[] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    little_endian_to_big_endian(test4, 32);
    uint8_t expected_result4[] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test4, expected_result4, sizeof(expected_result4)) == 0);
    return 0;
}

static char* test_hex_string_to_byte_array() {
    char* string = "0100000001d1c789a9c60383bf715f3f6ad9d14b91fe55f3deb369fe5d9280cb1a01793f81000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600";
    uint8_t expected_result[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    uint8_t result[226] = {0};
    hex_string_to_byte_array(string, result);
    mu_assert("Error: hex_string_to_byte_array doesn't work", memcmp(result, expected_result, 226) == 0);
    return 0;
}

static char* test_byte_array_to_hex_string() {
    uint8_t byte_array[32] = {0x27, 0xe0, 0xc5, 0x99, 0x4d, 0xec, 0x78, 0x24, 0xe5, 0x6d, 0xec, 0x6b, 0x2f, 0xcb, 0x34, 0x2e, 0xb7, 0xcd, 0xb0, 0xd0, 0x95, 0x7c, 0x2f, 0xce, 0x98, 0x82, 0xf7, 0x15, 0xe8, 0x5d, 0x81, 0xa6};
    char result[65];
    byte_array_to_hex_string(byte_array, 32, result);
    mu_assert("Error: byte_array_to_hex_string doesn't work", strcmp(result, "27e0c5994dec7824e56dec6b2fcb342eb7cdb0d0957c2fce9882f715e85d81a6") == 0);
    return 0;
}

static char* test_h160_to_p2pkh_address() {
    uint32_t address1_size = 34;
    uint32_t address2_size = 34;
    uint8_t h160[20] = {0x74, 0xd6, 0x91, 0xda, 0x15, 0x74, 0xe6, 0xb3, 0xc1, 0x92, 0xec, 0xfb, 0x52, 0xcc, 0x89, 0x84, 0xee, 0x7b, 0x6c, 0x56};
    uint8_t address1[34] = {0};
    h160_to_p2pkh_address(h160, address1, &address1_size, false);
    uint8_t address2[34] = {0};
    h160_to_p2pkh_address(h160, address2, &address2_size, true);
    uint8_t expected_result1[34] = "1BenRpVUFK65JFWcQSuHnJKzc4M8ZP8Eqa";
    uint8_t expected_result2[34] = "mrAjisaT4LXL5MzE81sfcDYKU3wqWSvf9q";
    mu_assert("Error: h160_to_p2pkh_address doesn't work", memcmp(address1, expected_result1, 34) == 0);
    mu_assert("Error: h160_to_p2pkh_address doesn't work", memcmp(address2, expected_result2, 34) == 0);
    return 0;
}

static char* test_h160_to_p2sh_address() {
    uint32_t address1_size = 34;
    uint32_t address2_size = 35;
    uint8_t h160[20] = {0x74, 0xd6, 0x91, 0xda, 0x15, 0x74, 0xe6, 0xb3, 0xc1, 0x92, 0xec, 0xfb, 0x52, 0xcc, 0x89, 0x84, 0xee, 0x7b, 0x6c, 0x56};
    uint8_t address1[34] = {0};
    h160_to_p2sh_address(h160, address1, &address1_size, false);
    uint8_t address2[35] = {0};
    h160_to_p2sh_address(h160, address2, &address2_size, true);
    uint8_t expected_result1[34] = "3CLoMMyuoDQTPRD3XYZtCvgvkadrAdvdXh";
    uint8_t expected_result2[35] = "2N3u1R6uwQfuobCqbCgBkpsgBxvr1tZpe7B";
    mu_assert("Error: h160_to_p2sh_address doesn't work", memcmp(address1, expected_result1, 34) == 0);
    mu_assert("Error: h160_to_p2sh_address doesn't work", memcmp(address2, expected_result2, 35) == 0);
    return 0;
}

static char* generate_testnet_address() {
    mpz_t secret;
    hash_to_mpz_t((const uint8_t*)"test", 4, secret);
    PrivateKey* test_key = PrivateKey_init(secret);
    S256Point_toString(test_key->point);
    S256Field_toString(test_key->e);
    uint8_t testnet_address[1024];
    S256Point_address(test_key->point, testnet_address, true, true);
    printf("Testnet address: %s\n", testnet_address);
    PrivateKey_free(test_key);
    return 0;
}

static char* test_Tx_id() {
    uint8_t raw_tx[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    uint8_t result[32] = {0};
    Tx_id(test_tx, result);
    uint8_t expected_result[32] = {0x45, 0x2c, 0x62, 0x9d, 0x67, 0xe4, 0x1b, 0xae, 0xc3, 0xac, 0x6f, 0x04, 0xfe, 0x74, 0x4b, 0x4b, 0x96, 0x17, 0xf8, 0xf8, 0x59, 0xc6, 0x3b, 0x30, 0x02, 0xf8, 0x68, 0x4e, 0x7a, 0x4f, 0xee, 0x03};
    mu_assert("Error: Tx_id doesn't work", memcmp(result, expected_result, 32) == 0);
    Tx_free(test_tx);

    uint8_t raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc2, 0x28, 0x02, 0x1e, 0x1f, 0xee, 0x6f, 0x15, 0x8c, 0xc5, 0x06, 0xed, 0xea, 0x6b, 0xad, 0x7f, 0xfa, 0x42, 0x1d, 0xd1, 0x4f, 0xb7, 0xfd, 0x7e, 0x01, 0xc5, 0x0c, 0xc9, 0x69, 0x3e, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0x00, 0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x05, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x08, 0x1f, 0xbb, 0x6e, 0xc9, 0xd8, 0x31, 0x04, 0x36, 0x7e, 0xb1, 0xa6, 0xa5, 0x9e, 0x2a, 0x92, 0x41, 0x7d, 0x79, 0x29, 0x87, 0x00, 0x35, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x67, 0x73, 0x45, 0xc7, 0x37, 0x6d, 0xfd, 0xa2, 0xc5, 0x2a, 0xd9, 0xb6, 0xa1, 0x53, 0xb6, 0x43, 0xb6, 0x40, 0x9a, 0x37, 0x88, 0xac, 0xc7, 0xf3, 0x41, 0x16, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x23, 0x4c, 0x15, 0x75, 0x6b, 0x95, 0x99, 0x31, 0x4c, 0x92, 0x99, 0x34, 0x0e, 0xaa, 0xba, 0xb7, 0xf1, 0x81, 0x0d, 0x82, 0x87, 0xc0, 0x27, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x69, 0xbe, 0x3c, 0xa6, 0x19, 0x5e, 0xfc, 0xab, 0x51, 0x94, 0xe1, 0x53, 0x01, 0x64, 0xec, 0x47, 0x63, 0x7d, 0x44, 0x30, 0x87, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x87, 0xfa, 0xdb, 0xa6, 0x6b, 0x9e, 0x48, 0xc0, 0xc8, 0x08, 0x2f, 0x33, 0x10, 0x7f, 0xdb, 0x01, 0x97, 0x0e, 0xb8, 0x03, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, false);
    uint8_t serialized_tx_2[1024];
    Tx_serialize(tx_2, serialized_tx_2);
    uint8_t result_2[32] = {0};
    uint8_t expected_result_2[32] = {0x9e, 0x06, 0x7a, 0xed, 0xc6, 0x61, 0xfc, 0xa1, 0x48, 0xe1, 0x39, 0x53, 0xdf, 0x75, 0xf8, 0xca, 0x6e, 0xad, 0xa9, 0xce, 0x3b, 0x3d, 0x8d, 0x68, 0x63, 0x17, 0x69, 0xac, 0x60, 0x99, 0x91, 0x56};
    Tx_id(tx_2, result_2);
    mu_assert("Error: Tx_id doesn't work", memcmp(result_2, expected_result_2, 32) == 0);
    Tx_free(tx_2);
    return 0;
}

static char* test_Tx_parse_version() {
    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    mu_assert("Error: Tx_parse doesn't work for version", test_tx->version == 1);
    Tx_free(test_tx);

    uint8_t raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc2, 0x28, 0x02, 0x1e, 0x1f, 0xee, 0x6f, 0x15, 0x8c, 0xc5, 0x06, 0xed, 0xea, 0x6b, 0xad, 0x7f, 0xfa, 0x42, 0x1d, 0xd1, 0x4f, 0xb7, 0xfd, 0x7e, 0x01, 0xc5, 0x0c, 0xc9, 0x69, 0x3e, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0x00, 0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x05, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x08, 0x1f, 0xbb, 0x6e, 0xc9, 0xd8, 0x31, 0x04, 0x36, 0x7e, 0xb1, 0xa6, 0xa5, 0x9e, 0x2a, 0x92, 0x41, 0x7d, 0x79, 0x29, 0x87, 0x00, 0x35, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x67, 0x73, 0x45, 0xc7, 0x37, 0x6d, 0xfd, 0xa2, 0xc5, 0x2a, 0xd9, 0xb6, 0xa1, 0x53, 0xb6, 0x43, 0xb6, 0x40, 0x9a, 0x37, 0x88, 0xac, 0xc7, 0xf3, 0x41, 0x16, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x23, 0x4c, 0x15, 0x75, 0x6b, 0x95, 0x99, 0x31, 0x4c, 0x92, 0x99, 0x34, 0x0e, 0xaa, 0xba, 0xb7, 0xf1, 0x81, 0x0d, 0x82, 0x87, 0xc0, 0x27, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x69, 0xbe, 0x3c, 0xa6, 0x19, 0x5e, 0xfc, 0xab, 0x51, 0x94, 0xe1, 0x53, 0x01, 0x64, 0xec, 0x47, 0x63, 0x7d, 0x44, 0x30, 0x87, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x87, 0xfa, 0xdb, 0xa6, 0x6b, 0x9e, 0x48, 0xc0, 0xc8, 0x08, 0x2f, 0x33, 0x10, 0x7f, 0xdb, 0x01, 0x97, 0x0e, 0xb8, 0x03, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, false);
    mu_assert("Error: Tx_parse doesn't work for version", tx_2->version == 1);
    Tx_free(tx_2);
    return 0;
}

static char* test_Tx_parse_inputs() {
    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    mu_assert("Error: Tx_parse doesn't work for num_inputs", test_tx->num_inputs == 1);
    uint8_t want1[32] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81};
    mu_assert("Error: Tx_parse doesn't work for prev_tx", memcmp(test_tx->tx_ins[0]->prev_tx, want1, 32) == 0);
    mu_assert("Error: Tx_parse doesn't work for prev_index", test_tx->tx_ins[0]->prev_index == 0);
    uint8_t want2[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    uint8_t scriptsig_serialized[108];
    Script_serialize(test_tx->tx_ins[0]->script_sig, scriptsig_serialized);
    mu_assert("Error: Tx_parse doesn't work for script_sig", memcmp(scriptsig_serialized, want2, 108) == 0);
    mu_assert("Error: Tx_parse doesn't work for sequence", test_tx->tx_ins[0]->sequence == 0xfffffffe);
    Tx_free(test_tx);

    uint8_t raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc2, 0x28, 0x02, 0x1e, 0x1f, 0xee, 0x6f, 0x15, 0x8c, 0xc5, 0x06, 0xed, 0xea, 0x6b, 0xad, 0x7f, 0xfa, 0x42, 0x1d, 0xd1, 0x4f, 0xb7, 0xfd, 0x7e, 0x01, 0xc5, 0x0c, 0xc9, 0x69, 0x3e, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0x00, 0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x05, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x08, 0x1f, 0xbb, 0x6e, 0xc9, 0xd8, 0x31, 0x04, 0x36, 0x7e, 0xb1, 0xa6, 0xa5, 0x9e, 0x2a, 0x92, 0x41, 0x7d, 0x79, 0x29, 0x87, 0x00, 0x35, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x67, 0x73, 0x45, 0xc7, 0x37, 0x6d, 0xfd, 0xa2, 0xc5, 0x2a, 0xd9, 0xb6, 0xa1, 0x53, 0xb6, 0x43, 0xb6, 0x40, 0x9a, 0x37, 0x88, 0xac, 0xc7, 0xf3, 0x41, 0x16, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x23, 0x4c, 0x15, 0x75, 0x6b, 0x95, 0x99, 0x31, 0x4c, 0x92, 0x99, 0x34, 0x0e, 0xaa, 0xba, 0xb7, 0xf1, 0x81, 0x0d, 0x82, 0x87, 0xc0, 0x27, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x69, 0xbe, 0x3c, 0xa6, 0x19, 0x5e, 0xfc, 0xab, 0x51, 0x94, 0xe1, 0x53, 0x01, 0x64, 0xec, 0x47, 0x63, 0x7d, 0x44, 0x30, 0x87, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x87, 0xfa, 0xdb, 0xa6, 0x6b, 0x9e, 0x48, 0xc0, 0xc8, 0x08, 0x2f, 0x33, 0x10, 0x7f, 0xdb, 0x01, 0x97, 0x0e, 0xb8, 0x03, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, false);
    mu_assert("Error: Tx_parse doesn't work for num_inputs", tx_2->num_inputs == 1);
    uint8_t want_1[32] = {0xbe, 0x8d, 0x3e, 0x69, 0xc9, 0x0c, 0xc5, 0x01, 0x7e, 0xfd, 0xb7, 0x4f, 0xd1, 0x1d, 0x42, 0xfa, 0x7f, 0xad, 0x6b, 0xea, 0xed, 0x06, 0xc5, 0x8c, 0x15, 0x6f, 0xee, 0x1f, 0x1e, 0x02, 0x28, 0xc2};
    mu_assert("Error: Tx_parse doesn't work for prev_tx", memcmp(tx_2->tx_ins[0]->prev_tx, want_1, 32) == 0);
    mu_assert("Error: Tx_parse doesn't work for prev_index", tx_2->tx_ins[0]->prev_index == 2);
    uint8_t want_2[] = {0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae};
    uint8_t scriptsig_serialized_2[257];
    Script_serialize(tx_2->tx_ins[0]->script_sig, scriptsig_serialized_2);
    mu_assert("Error: Tx_parse doesn't work for script_sig", memcmp(scriptsig_serialized_2, want_2, 257) == 0);
    mu_assert("Error: Tx_parse doesn't work for sequence", tx_2->tx_ins[0]->sequence == 0xffffffff);
    Tx_free(tx_2);
    return 0;
}

static char* test_Tx_parse_outputs() {
    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    mu_assert("Error: Tx_parse doesn't work for num_outputs", test_tx->num_outputs == 2);
    uint64_t want1 = 32454049;
    mu_assert("Error: Tx_parse doesn't work for amount", test_tx->tx_outs[0]->amount == want1);
    uint8_t want2[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    uint8_t scriptpubkey_serialized_1[26];
    Script_serialize(test_tx->tx_outs[0]->script_pubkey, scriptpubkey_serialized_1);
    mu_assert("Error: Tx_parse doesn't work for script_pubkey", memcmp(scriptpubkey_serialized_1, want2, 26) == 0);
    uint64_t want3 = 10011545;
    mu_assert("Error: Tx_parse doesn't work for amount", test_tx->tx_outs[1]->amount == want3);
    uint8_t want4[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    uint8_t scriptpubkey_serialized_2[26];
    Script_serialize(test_tx->tx_outs[1]->script_pubkey, scriptpubkey_serialized_2);
    mu_assert("Error: Tx_parse doesn't work for script_pubkey", memcmp(scriptpubkey_serialized_2, want4, 26) == 0);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse_locktime() {
    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    mu_assert("Error: Tx_parse doesn't work for locktime", test_tx->locktime == 410393);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse() {
    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x04, 0x56, 0x91, 0x99, 0x60, 0xac, 0x69, 0x17, 0x63, 0x68, 0x8d, 0x3d, 0x3b, 0xce, 0xa9, 0xad, 0x6e, 0xca, 0xf8, 0x75, 0xdf, 0x53, 0x39, 0xe1, 0x48, 0xa1, 0xfc, 0x61, 0xc6, 0xed, 0x7a, 0x06, 0x9e, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x45, 0x85, 0xbc, 0xde, 0xf8, 0x5e, 0x6b, 0x1c, 0x6a, 0xf5, 0xc2, 0x66, 0x9d, 0x48, 0x30, 0xff, 0x86, 0xe4, 0x2d, 0xd2, 0x05, 0xc0, 0xe0, 0x89, 0xbc, 0x2a, 0x82, 0x16, 0x57, 0xe9, 0x51, 0xc0, 0x02, 0x20, 0x10, 0x24, 0xa1, 0x03, 0x66, 0x07, 0x7f, 0x87, 0xd6, 0xbc, 0xe1, 0xf7, 0x10, 0x0a, 0xd8, 0xcf, 0xa8, 0xa0, 0x64, 0xb3, 0x9d, 0x4e, 0x8f, 0xe4, 0xea, 0x13, 0xa7, 0xb7, 0x1a, 0xa8, 0x18, 0x0f, 0x01, 0x21, 0x02, 0xf0, 0xda, 0x57, 0xe8, 0x5e, 0xec, 0x29, 0x34, 0xa8, 0x2a, 0x58, 0x5e, 0xa3, 0x37, 0xce, 0x2f, 0x49, 0x98, 0xb5, 0x0a, 0xe6, 0x99, 0xdd, 0x79, 0xf5, 0x88, 0x0e, 0x25, 0x3d, 0xaf, 0xaf, 0xb7, 0xfe, 0xff, 0xff, 0xff, 0xeb, 0x8f, 0x51, 0xf4, 0x03, 0x8d, 0xc1, 0x7e, 0x63, 0x13, 0xcf, 0x83, 0x1d, 0x4f, 0x02, 0x28, 0x1c, 0x2a, 0x46, 0x8b, 0xde, 0x0f, 0xaf, 0xd3, 0x7f, 0x1b, 0xf8, 0x82, 0x72, 0x9e, 0x7f, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37, 0xfe, 0xff, 0xff, 0xff, 0x56, 0x7b, 0xf4, 0x05, 0x95, 0x11, 0x9d, 0x1b, 0xb8, 0xa3, 0x03, 0x7c, 0x35, 0x6e, 0xfd, 0x56, 0x17, 0x0b, 0x64, 0xcb, 0xcc, 0x16, 0x0f, 0xb0, 0x28, 0xfa, 0x10, 0x70, 0x4b, 0x45, 0xd7, 0x75, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x4c, 0x7c, 0x78, 0x18, 0x42, 0x4c, 0x7f, 0x79, 0x11, 0xda, 0x6c, 0xdd, 0xc5, 0x96, 0x55, 0xa7, 0x0a, 0xf1, 0xcb, 0x5e, 0xaf, 0x17, 0xc6, 0x9d, 0xad, 0xbf, 0xc7, 0x4f, 0xfa, 0x0b, 0x66, 0x2f, 0x02, 0x20, 0x75, 0x99, 0xe0, 0x8b, 0xc8, 0x02, 0x36, 0x93, 0xad, 0x4e, 0x95, 0x27, 0xdc, 0x42, 0xc3, 0x42, 0x10, 0xf7, 0xa7, 0xd1, 0xd1, 0xdd, 0xfc, 0x84, 0x92, 0xb6, 0x54, 0xa1, 0x1e, 0x76, 0x20, 0xa0, 0x01, 0x21, 0x02, 0x15, 0x8b, 0x46, 0xfb, 0xdf, 0xf6, 0x5d, 0x01, 0x72, 0xb7, 0x98, 0x9a, 0xec, 0x88, 0x50, 0xaa, 0x0d, 0xae, 0x49, 0xab, 0xfb, 0x84, 0xc8, 0x1a, 0xe6, 0xe5, 0xb2, 0x51, 0xa5, 0x8a, 0xce, 0x5c, 0xfe, 0xff, 0xff, 0xff, 0xd6, 0x3a, 0x5e, 0x6c, 0x16, 0xe6, 0x20, 0xf8, 0x6f, 0x37, 0x59, 0x25, 0xb2, 0x1c, 0xab, 0xaf, 0x73, 0x6c, 0x77, 0x9f, 0x88, 0xfd, 0x04, 0xdc, 0xad, 0x51, 0xd2, 0x66, 0x90, 0xf7, 0xf3, 0x45, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x06, 0x33, 0xea, 0x0d, 0x33, 0x14, 0xbe, 0xa0, 0xd9, 0x5b, 0x3c, 0xd8, 0xda, 0xdb, 0x2e, 0xf7, 0x9e, 0xa8, 0x33, 0x1f, 0xfe, 0x1e, 0x61, 0xf7, 0x62, 0xc0, 0xf6, 0xda, 0xea, 0x0f, 0xab, 0xde, 0x02, 0x20, 0x29, 0xf2, 0x3b, 0x3e, 0x9c, 0x30, 0xf0, 0x80, 0x44, 0x61, 0x50, 0xb2, 0x38, 0x52, 0x02, 0x87, 0x51, 0x63, 0x5d, 0xce, 0xe2, 0xbe, 0x66, 0x9c, 0x2a, 0x16, 0x86, 0xa4, 0xb5, 0xed, 0xf3, 0x04, 0x01, 0x21, 0x03, 0xff, 0xd6, 0xf4, 0xa6, 0x7e, 0x94, 0xab, 0xa3, 0x53, 0xa0, 0x08, 0x82, 0xe5, 0x63, 0xff, 0x27, 0x22, 0xeb, 0x4c, 0xff, 0x0a, 0xd6, 0x00, 0x6e, 0x86, 0xee, 0x20, 0xdf, 0xe7, 0x52, 0x0d, 0x55, 0xfe, 0xff, 0xff, 0xff, 0x02, 0x51, 0x43, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xab, 0x0c, 0x0b, 0x2e, 0x98, 0xb1, 0xab, 0x6d, 0xbf, 0x67, 0xd4, 0x75, 0x0b, 0x0a, 0x56, 0x24, 0x49, 0x48, 0xa8, 0x79, 0x88, 0xac, 0x00, 0x5a, 0x62, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x3c, 0x82, 0xd7, 0xdf, 0x36, 0x4e, 0xb6, 0xc7, 0x5b, 0xe8, 0xc8, 0x0d, 0xf2, 0xb3, 0xed, 0xa8, 0xdb, 0x57, 0x39, 0x70, 0x88, 0xac, 0x46, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    mu_assert("Error: Tx_parse doesn't work for version", test_tx->version == 1);
    mu_assert("Error: Tx_parse doesn't work for num_inputs", test_tx->num_inputs == 4);
    mu_assert("Error: Tx_parse doesn't work for num_outputs", test_tx->num_outputs == 2);
    mu_assert("Error: Tx_parse doesn't work for locktime", test_tx->locktime == 410438);
    Tx_free(test_tx);
    return 0;
}

static char* test_print_formatted_bytes() {
    const uint8_t* hex_string = (const uint8_t*)"01000000018135af648c80302ef800b4deaa752b65ea14ec85184c9a892760f5cb48edcfb7000000006b483045022100a4f17623d5098084bc645b60b19d3a1d1007afdc7aab9098458bdc03b3301307022040a6eb80e717d68f5d4d9d45c3e554dadfe59ddf5da390e0402630d4c0e86223012103c0df4f18b17d4b123e5e8b0baae79cc6fba8f27838d9a8a9efb165bf5e207186ffffffff0288130000000000001976a91480363139c840aaebe2cd2e2c355e259f43461f6c88acd0070000000000001976a914b89f3cb5555fa0dbb5e1439b050795f31d103b2e88ac00000000";
    print_formatted_bytes(hex_string);
    const uint8_t* hex_string_2 = (const uint8_t*)"3045022100eadc1c6e72f241c3e076a7109b8053db53987f3fcc99e3f88fc4e52dbfd5f3a202201f02cbff194c41e6f8da762e024a7ab85c1b1616b74720f13283043e9e99dab801";
    print_formatted_bytes(hex_string_2);
    const uint8_t* hex_string3 = (const uint8_t*)"522102b0c7be446b92624112f3c7d4ffc214921c74c1cb891bf945c49fbe5981ee026b21039021c9391e328e0cb3b61ba05dcc5e122ab234e55d1502e59b10d8f588aea4632102f3bd8f64363066f35968bd82ed9c6e8afecbd6136311bb51e91204f614144e9b53ae";
    print_formatted_bytes(hex_string3);
    const uint8_t* hex_string_4 = (const uint8_t*)"475221022626e955ea6ea6d98850c994f9107b036b1334f18ca8830bfff1295d21cfdb702103b287eaf122eea69030a0e9feed096bed8045c8b98bec453e1ffac7fbdbd4bb7152ae";
    print_formatted_bytes(hex_string_4);
    return 0;
}

static char* test_TxOut_serialize() {
    uint8_t script_pubkey_1_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    Script* script_pubkey_1 = Script_init();
    Command cmd_1;
    memcpy(cmd_1.data, script_pubkey_1_raw + 1, 24);
    cmd_1.data_len = 24;
    Command cmd_2;
    cmd_2.data[0] = 0xac;
    cmd_2.data_len = 1;
    script_pubkey_1->cmds[0] = cmd_1;
    script_pubkey_1->cmds[1] = cmd_2;
    script_pubkey_1->cmds_len = 2;
    TxOut* tx_out_1 = TxOut_init(32454049, script_pubkey_1);
    uint8_t result_1[35];
    TxOut_serialize(tx_out_1, result_1);
    uint8_t expected_result_1[35] = {0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x18, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_1, expected_result_1, 35) == 0);
    TxOut_free(tx_out_1);

    Script* script_pubkey_3 = Script_parse(script_pubkey_1_raw);
    TxOut* tx_out_3 = TxOut_init(32454049, script_pubkey_3);
    uint8_t result_3[34];
    TxOut_serialize(tx_out_3, result_3);
    uint8_t expected_result_3[34] = {0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_3, expected_result_3, 34) == 0);
    TxOut_free(tx_out_3);

    uint8_t script_pubkey_2_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    Script* script_pubkey_2 = Script_init();
    Command cmd_3;
    memcpy(cmd_3.data, script_pubkey_2_raw + 1, 24);
    cmd_3.data_len = 24;
    Command cmd_4;
    cmd_4.data[0] = 0xac;
    cmd_4.data_len = 1;
    script_pubkey_2->cmds[0] = cmd_3;
    script_pubkey_2->cmds[1] = cmd_4;
    script_pubkey_2->cmds_len = 2;
    TxOut* tx_out_2 = TxOut_init(10011545, script_pubkey_2);
    uint8_t result_2[35];
    TxOut_serialize(tx_out_2, result_2);
    uint8_t expected_result_2[] = {0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x18, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_2, expected_result_2, 35) == 0);
    TxOut_free(tx_out_2);
    return 0;
}

static char* test_TxIn_serialize() {
    uint8_t prev_tx[32] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    int32_t prev_index = 0;
    uint8_t script_sig_raw[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_sig = Script_parse(script_sig_raw);
    int32_t sequence = 0xfffffffe;
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, sequence);
    uint8_t result[148];
    TxIn_serialize(tx_in, result);
    uint8_t expected_result[] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff};
    mu_assert("Error: TxIn_serialize doesn't work", memcmp(result, expected_result, 148) == 0);
    TxIn_free(tx_in);
    return 0;
}

static char* test_Tx_serialize() {
    int32_t version = 1;
    uint64_t num_inputs = 1;
    uint64_t num_outputs = 2;
    uint64_t locktime = 410393;
    TxIn** tx_ins = (TxIn**)malloc(num_inputs * sizeof(TxIn*));
    uint8_t prev_tx[32] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    int32_t prev_index = 0;
    uint8_t script_sig_raw[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_sig = Script_parse(script_sig_raw);
    int32_t sequence = 0xfffffffe;
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, sequence);
    tx_ins[0] = tx_in;
    TxOut** tx_outs = (TxOut**)malloc(num_outputs * sizeof(TxOut*));
    uint8_t script_pubkey_1_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    Script* script_pubkey_1 = Script_parse(script_pubkey_1_raw);
    TxOut* tx_out_1 = TxOut_init(32454049, script_pubkey_1);
    tx_outs[0] = tx_out_1;
    uint8_t script_pubkey_2_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    Script* script_pubkey_2 = Script_parse(script_pubkey_2_raw);
    TxOut* tx_out_2 = TxOut_init(10011545, script_pubkey_2);
    tx_outs[1] = tx_out_2;
    Tx* tx = Tx_init(version, num_inputs, tx_ins, num_outputs, tx_outs, locktime, false, false);
    uint8_t result[226];
    Tx_serialize(tx, result);
    for (int32_t i = 0; i < 226; i++) {
        printf("%02x", result[i]);
    }
    printf("\n");
    uint8_t expected_result[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    mu_assert("Error: Tx_serialize doesn't work", memcmp(result, expected_result, 226) == 0);
    Tx_free(tx);

    uint8_t raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc2, 0x28, 0x02, 0x1e, 0x1f, 0xee, 0x6f, 0x15, 0x8c, 0xc5, 0x06, 0xed, 0xea, 0x6b, 0xad, 0x7f, 0xfa, 0x42, 0x1d, 0xd1, 0x4f, 0xb7, 0xfd, 0x7e, 0x01, 0xc5, 0x0c, 0xc9, 0x69, 0x3e, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0x00, 0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x05, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x08, 0x1f, 0xbb, 0x6e, 0xc9, 0xd8, 0x31, 0x04, 0x36, 0x7e, 0xb1, 0xa6, 0xa5, 0x9e, 0x2a, 0x92, 0x41, 0x7d, 0x79, 0x29, 0x87, 0x00, 0x35, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x67, 0x73, 0x45, 0xc7, 0x37, 0x6d, 0xfd, 0xa2, 0xc5, 0x2a, 0xd9, 0xb6, 0xa1, 0x53, 0xb6, 0x43, 0xb6, 0x40, 0x9a, 0x37, 0x88, 0xac, 0xc7, 0xf3, 0x41, 0x16, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x23, 0x4c, 0x15, 0x75, 0x6b, 0x95, 0x99, 0x31, 0x4c, 0x92, 0x99, 0x34, 0x0e, 0xaa, 0xba, 0xb7, 0xf1, 0x81, 0x0d, 0x82, 0x87, 0xc0, 0x27, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x69, 0xbe, 0x3c, 0xa6, 0x19, 0x5e, 0xfc, 0xab, 0x51, 0x94, 0xe1, 0x53, 0x01, 0x64, 0xec, 0x47, 0x63, 0x7d, 0x44, 0x30, 0x87, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x87, 0xfa, 0xdb, 0xa6, 0x6b, 0x9e, 0x48, 0xc0, 0xc8, 0x08, 0x2f, 0x33, 0x10, 0x7f, 0xdb, 0x01, 0x97, 0x0e, 0xb8, 0x03, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, false);
    uint8_t result_2[471];
    Tx_serialize(test_tx, result_2);
    mu_assert("Error: Tx_serialize doesn't work", memcmp(result_2, raw_tx, 471) == 0);
    Tx_free(test_tx);
    return 0;
}

static char* test_http_get() {
    // const char* url = "http://httpbin.org/get";
    const char* url = "https://blockstream.info/api/tx/d1c789a9c60383bf715f3f6ad9d14b91fe55f3deb369fe5d9280cb1a01793f81/hex";
    char response[10000] = {0};
    char* expected_response = "0100000002137c53f0fb48f83666fcfd2fe9f12d13e94ee109c5aeabbfa32bb9e02538f4cb000000006a47304402207e6009ad86367fc4b166bc80bf10cf1e78832a01e9bb491c6d126ee8aa436cb502200e29e6dd7708ed419cd5ba798981c960f0cc811b24e894bff072fea8074a7c4c012103bc9e7397f739c70f424aa7dcce9d2e521eb228b0ccba619cd6a0b9691da796a1ffffffff517472e77bc29ae59a914f55211f05024556812a2dd7d8df293265acd8330159010000006b483045022100f4bfdb0b3185c778cf28acbaf115376352f091ad9e27225e6f3f350b847579c702200d69177773cd2bb993a816a5ae08e77a6270cf46b33f8f79d45b0cd1244d9c4c0121031c0b0b95b522805ea9d0225b1946ecaeb1727c0b36c7e34165769fd8ed860bf5ffffffff027a958802000000001976a914a802fc56c704ce87c42d7c92eb75e7896bdc41ae88aca5515e00000000001976a914e82bd75c9c662c3f5700b33fec8a676b6e9391d588ac00000000";
    http_get(url, response);
    mu_assert("Error: http_get doesn't work", memcmp((const char*)response, (const char*)expected_response, 746) == 0);
    return 0;
}

static char* test_fee() {
    uint8_t raw_tx_1[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* tx_1 = Tx_parse(raw_tx_1, false);
    uint64_t fee_1 = fee(tx_1, false);
    mu_assert("Error: fee doesn't work", fee_1 == 40000);
    Tx_free(tx_1);

    uint8_t raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x04, 0x56, 0x91, 0x99, 0x60, 0xac, 0x69, 0x17, 0x63, 0x68, 0x8d, 0x3d, 0x3b, 0xce, 0xa9, 0xad, 0x6e, 0xca, 0xf8, 0x75, 0xdf, 0x53, 0x39, 0xe1, 0x48, 0xa1, 0xfc, 0x61, 0xc6, 0xed, 0x7a, 0x06, 0x9e, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x45, 0x85, 0xbc, 0xde, 0xf8, 0x5e, 0x6b, 0x1c, 0x6a, 0xf5, 0xc2, 0x66, 0x9d, 0x48, 0x30, 0xff, 0x86, 0xe4, 0x2d, 0xd2, 0x05, 0xc0, 0xe0, 0x89, 0xbc, 0x2a, 0x82, 0x16, 0x57, 0xe9, 0x51, 0xc0, 0x02, 0x20, 0x10, 0x24, 0xa1, 0x03, 0x66, 0x07, 0x7f, 0x87, 0xd6, 0xbc, 0xe1, 0xf7, 0x10, 0x0a, 0xd8, 0xcf, 0xa8, 0xa0, 0x64, 0xb3, 0x9d, 0x4e, 0x8f, 0xe4, 0xea, 0x13, 0xa7, 0xb7, 0x1a, 0xa8, 0x18, 0x0f, 0x01, 0x21, 0x02, 0xf0, 0xda, 0x57, 0xe8, 0x5e, 0xec, 0x29, 0x34, 0xa8, 0x2a, 0x58, 0x5e, 0xa3, 0x37, 0xce, 0x2f, 0x49, 0x98, 0xb5, 0x0a, 0xe6, 0x99, 0xdd, 0x79, 0xf5, 0x88, 0x0e, 0x25, 0x3d, 0xaf, 0xaf, 0xb7, 0xfe, 0xff, 0xff, 0xff, 0xeb, 0x8f, 0x51, 0xf4, 0x03, 0x8d, 0xc1, 0x7e, 0x63, 0x13, 0xcf, 0x83, 0x1d, 0x4f, 0x02, 0x28, 0x1c, 0x2a, 0x46, 0x8b, 0xde, 0x0f, 0xaf, 0xd3, 0x7f, 0x1b, 0xf8, 0x82, 0x72, 0x9e, 0x7f, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37, 0xfe, 0xff, 0xff, 0xff, 0x56, 0x7b, 0xf4, 0x05, 0x95, 0x11, 0x9d, 0x1b, 0xb8, 0xa3, 0x03, 0x7c, 0x35, 0x6e, 0xfd, 0x56, 0x17, 0x0b, 0x64, 0xcb, 0xcc, 0x16, 0x0f, 0xb0, 0x28, 0xfa, 0x10, 0x70, 0x4b, 0x45, 0xd7, 0x75, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x4c, 0x7c, 0x78, 0x18, 0x42, 0x4c, 0x7f, 0x79, 0x11, 0xda, 0x6c, 0xdd, 0xc5, 0x96, 0x55, 0xa7, 0x0a, 0xf1, 0xcb, 0x5e, 0xaf, 0x17, 0xc6, 0x9d, 0xad, 0xbf, 0xc7, 0x4f, 0xfa, 0x0b, 0x66, 0x2f, 0x02, 0x20, 0x75, 0x99, 0xe0, 0x8b, 0xc8, 0x02, 0x36, 0x93, 0xad, 0x4e, 0x95, 0x27, 0xdc, 0x42, 0xc3, 0x42, 0x10, 0xf7, 0xa7, 0xd1, 0xd1, 0xdd, 0xfc, 0x84, 0x92, 0xb6, 0x54, 0xa1, 0x1e, 0x76, 0x20, 0xa0, 0x01, 0x21, 0x02, 0x15, 0x8b, 0x46, 0xfb, 0xdf, 0xf6, 0x5d, 0x01, 0x72, 0xb7, 0x98, 0x9a, 0xec, 0x88, 0x50, 0xaa, 0x0d, 0xae, 0x49, 0xab, 0xfb, 0x84, 0xc8, 0x1a, 0xe6, 0xe5, 0xb2, 0x51, 0xa5, 0x8a, 0xce, 0x5c, 0xfe, 0xff, 0xff, 0xff, 0xd6, 0x3a, 0x5e, 0x6c, 0x16, 0xe6, 0x20, 0xf8, 0x6f, 0x37, 0x59, 0x25, 0xb2, 0x1c, 0xab, 0xaf, 0x73, 0x6c, 0x77, 0x9f, 0x88, 0xfd, 0x04, 0xdc, 0xad, 0x51, 0xd2, 0x66, 0x90, 0xf7, 0xf3, 0x45, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x06, 0x33, 0xea, 0x0d, 0x33, 0x14, 0xbe, 0xa0, 0xd9, 0x5b, 0x3c, 0xd8, 0xda, 0xdb, 0x2e, 0xf7, 0x9e, 0xa8, 0x33, 0x1f, 0xfe, 0x1e, 0x61, 0xf7, 0x62, 0xc0, 0xf6, 0xda, 0xea, 0x0f, 0xab, 0xde, 0x02, 0x20, 0x29, 0xf2, 0x3b, 0x3e, 0x9c, 0x30, 0xf0, 0x80, 0x44, 0x61, 0x50, 0xb2, 0x38, 0x52, 0x02, 0x87, 0x51, 0x63, 0x5d, 0xce, 0xe2, 0xbe, 0x66, 0x9c, 0x2a, 0x16, 0x86, 0xa4, 0xb5, 0xed, 0xf3, 0x04, 0x01, 0x21, 0x03, 0xff, 0xd6, 0xf4, 0xa6, 0x7e, 0x94, 0xab, 0xa3, 0x53, 0xa0, 0x08, 0x82, 0xe5, 0x63, 0xff, 0x27, 0x22, 0xeb, 0x4c, 0xff, 0x0a, 0xd6, 0x00, 0x6e, 0x86, 0xee, 0x20, 0xdf, 0xe7, 0x52, 0x0d, 0x55, 0xfe, 0xff, 0xff, 0xff, 0x02, 0x51, 0x43, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xab, 0x0c, 0x0b, 0x2e, 0x98, 0xb1, 0xab, 0x6d, 0xbf, 0x67, 0xd4, 0x75, 0x0b, 0x0a, 0x56, 0x24, 0x49, 0x48, 0xa8, 0x79, 0x88, 0xac, 0x00, 0x5a, 0x62, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x3c, 0x82, 0xd7, 0xdf, 0x36, 0x4e, 0xb6, 0xc7, 0x5b, 0xe8, 0xc8, 0x0d, 0xf2, 0xb3, 0xed, 0xa8, 0xdb, 0x57, 0x39, 0x70, 0x88, 0xac, 0x46, 0x43, 0x06, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, false);
    uint64_t fee_2 = fee(tx_2, false);
    mu_assert("Error: fee doesn't work", fee_2 == 140500);
    Tx_free(tx_2);
    return 0;
}

static char* test_sig_hash() {
    uint8_t raw_tx[32] = {0x45, 0x2c, 0x62, 0x9d, 0x67, 0xe4, 0x1b, 0xae, 0xc3, 0xac, 0x6f, 0x04, 0xfe, 0x74, 0x4b, 0x4b, 0x96, 0x17, 0xf8, 0xf8, 0x59, 0xc6, 0x3b, 0x30, 0x02, 0xf8, 0x68, 0x4e, 0x7a, 0x4f, 0xee, 0x03};
    uint8_t want[32] = {0x27, 0xe0, 0xc5, 0x99, 0x4d, 0xec, 0x78, 0x24, 0xe5, 0x6d, 0xec, 0x6b, 0x2f, 0xcb, 0x34, 0x2e, 0xb7, 0xcd, 0xb0, 0xd0, 0x95, 0x7c, 0x2f, 0xce, 0x98, 0x82, 0xf7, 0x15, 0xe8, 0x5d, 0x81, 0xa6};
    uint8_t result[32] = {0};
    Tx* tx = fetch(raw_tx, false);
    sig_hash(tx, 0, result, NULL);
    mu_assert("Error: sig_hash doesn't work", memcmp(result, want, 32) == 0);
    Tx_free(tx);
    return 0;
}

static char* test_encode_num() {
    long long num_1 = 0;
    uint8_t result_1[1];
    encode_num(num_1, result_1);
    uint8_t expected_result_1[1] = {0x00};
    mu_assert("Error: encode_num doesn't work", memcmp(result_1, expected_result_1, 1) == 0);
    long long num_2 = 252;
    uint8_t result_2[2];
    encode_num(num_2, result_2);
    uint8_t expected_result_2[2] = {0xfc, 0x00};
    mu_assert("Error: encode_num doesn't work", memcmp(result_2, expected_result_2, 1) == 0);
    long long num_3 = -1;
    uint8_t result_3[1];
    encode_num(num_3, result_3);
    uint8_t expected_result_3[1] = {0x81};
    mu_assert("Error: encode_num doesn't work", memcmp(result_3, expected_result_3, 1) == 0);
    long long num_4 = 1098523;
    uint8_t result_4[3];
    encode_num(num_4, result_4);
    uint8_t expected_result_4[3] = {0x1b, 0xc3, 0x10};
    mu_assert("Error: encode_num doesn't work", memcmp(result_4, expected_result_4, 3) == 0);
    long long num_5 = -1098523;
    uint8_t result_5[3];
    encode_num(num_5, result_5);
    uint8_t expected_result_5[3] = {0x1b, 0xc3, 0x90};
    mu_assert("Error: encode_num doesn't work", memcmp(result_5, expected_result_5, 3) == 0);
    long long num_6 = -252;
    uint8_t result_6[2];
    encode_num(num_6, result_6);
    uint8_t expected_result_6[2] = {0xfc, 0x80};
    mu_assert("Error: encode_num doesn't work", memcmp(result_6, expected_result_6, 2) == 0);
    return 0;
}

static char* test_decode_num() {
    uint8_t raw_num_1[] = {0x00};
    long long result_1 = decode_num(raw_num_1, 1);
    long long expected_result_1 = 0;
    mu_assert("Error: decode_num doesn't work", result_1 == expected_result_1);
    uint8_t raw_num_2[] = {0xfc, 0x00};
    long long result_2 = decode_num(raw_num_2, 2);
    long long expected_result_2 = 252;
    mu_assert("Error: decode_num doesn't work", result_2 == expected_result_2);
    uint8_t raw_num_3[] = {0x81};
    long long result_3 = decode_num(raw_num_3, 1);
    long long expected_result_3 = -1;
    mu_assert("Error: decode_num doesn't work", result_3 == expected_result_3);
    uint8_t raw_num_4[] = {0x1b, 0xc3, 0x10};
    long long result_4 = decode_num(raw_num_4, 3);
    long long expected_result_4 = 1098523;
    mu_assert("Error: decode_num doesn't work", result_4 == expected_result_4);
    uint8_t raw_num_5[] = {0x1b, 0xc3, 0x90};
    long long result_5 = decode_num(raw_num_5, 3);
    long long expected_result_5 = -1098523;
    mu_assert("Error: decode_num doesn't work", result_5 == expected_result_5);
    uint8_t raw_num_6[] = {0xfc, 0x80};
    long long result_6 = decode_num(raw_num_6, 2);
    long long expected_result_6 = -252;
    mu_assert("Error: decode_num doesn't work", result_6 == expected_result_6);
    return 0;
}

static char* test_Op_hash160() {
    Op* test_op = Op_init();
    uint8_t test[11] = "hello world";
    push(test_op, test, 11);
    size_t worked = Op_hash160(test_op);
    uint8_t result[20] = {0};
    peek(test_op, result);
    uint8_t expected_result[20] = {0xd7, 0xd5, 0xee, 0x78, 0x24, 0xff, 0x93, 0xf9, 0x4c, 0x30, 0x55, 0xaf, 0x93, 0x82, 0xc8, 0x6c, 0x68, 0xb5, 0xca, 0x92};
    Op_free(test_op);
    mu_assert("Error: Op_hash160 doesn't work", worked);
    mu_assert("Error: Op_hash160 doesn't work", memcmp(result, expected_result, 20) == 0);
    return 0;
}

static char* test_Op_checksig() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    uint8_t sec[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    uint8_t sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    Op* op = Op_init();
    push(op, sig, 72);
    push(op, sec, 65);
    size_t checksig = Op_checksig(op, test_z);
    mu_assert("Error: Op_checksig doesn't work", checksig);
    long long num = decode_num(op->stack[0], 1);
    mu_assert("Error: Op_checksig doesn't work", num == 1);
    Op_free(op);
    S256Field_free(test_z);
    return 0;
}

static char* test_Script_length() {
    uint8_t script_pubkey[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script = Script_parse(script_pubkey);
    uint64_t length = Script_length(script);
    mu_assert("Error: script_length doesn't work", length == 107);
    free(script);
    return 0;
}

static char* test_p2pkh_script() {
    uint8_t prev_tx[32] = {0x0d, 0x6f, 0xe5, 0x21, 0x3c, 0x0b, 0x32, 0x91, 0xf2, 0x08, 0xcb, 0xa8, 0xbf, 0xb5, 0x9b, 0x74, 0x76, 0xdf, 0xfa, 0xcc, 0x4e, 0x5c, 0xb6, 0x6f, 0x6e, 0xb2, 0x0a, 0x08, 0x08, 0x43, 0xa2, 0x99};
    int prev_index = 13;
    Script* script_sig = Script_init();
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, 0xffffffff);
    uint64_t change_amount = 33000000ULL;
    uint8_t change_h160[20] = {0};
    const char* change_base58 = "mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2";
    decode_base58(change_base58, change_h160);
    Script* change_script = p2pkh_script(change_h160);
    TxOut* change_output = TxOut_init(change_amount, change_script);
    uint64_t target_amount = 10000000ULL;
    uint8_t target_h160[20] = {0};
    const char* target_base58 = "mnrVtF8DWjMu839VW3rBfgYaAfKk8983Xf";
    decode_base58(target_base58, target_h160);
    Script* target_script = p2pkh_script(target_h160);
    TxOut* target_output = TxOut_init(target_amount, target_script);
    TxIn* inputs[1] = {tx_in};
    TxOut* outputs[2] = {change_output, target_output};
    Tx* tx_obj = Tx_init(1, 1, inputs, 2, outputs, 0, true, false);
    uint8_t tx_obj_expected[119] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x99, 0xa2, 0x43, 0x08, 0x08, 0x0a, 0xb2, 0x6e, 0x6f, 0xb6, 0x5c, 0x4e, 0xcc, 0xfa, 0xdf, 0x76, 0x74, 0x9b, 0xb5, 0xbf, 0xa8, 0xcb, 0x08, 0xf2, 0x91, 0x32, 0x0b, 0x3c, 0x21, 0xe5, 0x6f, 0x0d, 0x0d, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x40, 0x8a, 0xf7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xd5, 0x2a, 0xd7, 0xca, 0x9b, 0x3d, 0x09, 0x6a, 0x38, 0xe7, 0x52, 0xc2, 0x01, 0x8e, 0x6f, 0xbc, 0x40, 0xcd, 0xf2, 0x6f, 0x88, 0xac, 0x80, 0x96, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x50, 0x7b, 0x27, 0x41, 0x1c, 0xcf, 0x7f, 0x16, 0xf1, 0x02, 0x97, 0xde, 0x6c, 0xef, 0x3f, 0x29, 0x16, 0x23, 0xed, 0xdf, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    uint8_t tx_obj_serialized[119] = {0};
    Tx_serialize(tx_obj, tx_obj_serialized);
    mu_assert("Error: p2pkh_script doesn't work", memcmp(tx_obj_serialized, tx_obj_expected, 119) == 0);
    for (uint64_t i = 0; i < tx_obj->num_inputs; i++) {
        TxIn_free(tx_obj->tx_ins[i]);
    }
    for (uint64_t i = 0; i < tx_obj->num_outputs; i++) {
        TxOut_free(tx_obj->tx_outs[i]);
    }
    free(tx_obj);
    return 0;
}

static char* test_Script_parse() {
    uint8_t script_pubkey[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script = Script_parse(script_pubkey);
    mu_assert("Error: script_parse doesn't work", script->cmds_len == 2);
    uint8_t want_1[] = {0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01};
    mu_assert("Error: script_parse doesn't work", memcmp(script->cmds[0].data, want_1, 71) == 0);
    uint8_t want_2[] = {0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    mu_assert("Error: script_parse doesn't work", memcmp(script->cmds[1].data, want_2, 33) == 0);
    Script_free(script);

    uint8_t raw_script[] = {0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae};
    Script* script_2 = Script_parse(raw_script);
    mu_assert("Error: script_parse doesn't work", script_2->cmds_len == 4);
    mu_assert("Error: script_parse doesn't work", script_2->cmds[0].data[0] == 0);
    uint8_t command_1[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01};
    uint8_t command_2[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01};
    uint8_t command_3[] = {0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae};
    mu_assert("Error: script_parse doesn't work", memcmp(script_2->cmds[1].data, command_1, 72) == 0);
    mu_assert("Error: script_parse doesn't work", memcmp(script_2->cmds[2].data, command_2, 72) == 0);
    mu_assert("Error: script_parse doesn't work", memcmp(script_2->cmds[3].data, command_3, 105) == 0);
    Script_free(script_2);
    return 0;
}

static char* test_Script_serialize() {
    uint8_t want[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script = Script_parse(want);
    uint8_t result[107];
    Script_serialize(script, result);
    mu_assert("Error: script_serialize doesn't work", memcmp(result, want, 107) == 0);
    Script_free(script);

    uint8_t want2[] = {0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae};
    Script* script_2 = Script_parse(want2);
    uint8_t result2[257];
    Script_serialize(script_2, result2);
    mu_assert("Error: script_serialize doesn't work", memcmp(result2, want2, 257) == 0);
    Script_free(script_2);
    return 0;
}

static char* test_Script_add() {
    uint8_t script_pubkey[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script_1 = Script_parse(script_pubkey);
    uint8_t script_sig[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_2 = Script_parse(script_sig);
    Script* result = Script_add(script_1, script_2);
    mu_assert("Error: script_add doesn't work", result->cmds_len == 4);
    uint8_t want_1[] = {0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[0].data, want_1, 71) == 0);
    uint8_t want_2[] = {0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[1].data, want_2, 33) == 0);
    uint8_t want_3[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[2].data, want_3, 72) == 0);
    uint8_t want_4[] = {0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[3].data, want_4, 33) == 0);
    Script_free(script_1);
    Script_free(script_2);
    Script_free(result);

    uint8_t script_sig_2[108] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    uint8_t script_pubkey_2[26] = {0x19, 0x76, 0xa9, 0x14, 0xa8, 0x02, 0xfc, 0x56, 0xc7, 0x04, 0xce, 0x87, 0xc4, 0x2d, 0x7c, 0x92, 0xeb, 0x75, 0xe7, 0x89, 0x6b, 0xdc, 0x41, 0xae, 0x88, 0xac};
    Script* script_3 = Script_parse(script_sig_2);
    Script* script_4 = Script_parse(script_pubkey_2);
    Script* result_2 = Script_add(script_3, script_4);
    uint8_t want_5[133] = {0x84, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0x76, 0xa9, 0x14, 0xa8, 0x02, 0xfc, 0x56, 0xc7, 0x04, 0xce, 0x87, 0xc4, 0x2d, 0x7c, 0x92, 0xeb, 0x75, 0xe7, 0x89, 0x6b, 0xdc, 0x41, 0xae, 0x88, 0xac};
    uint8_t result_2_serialized[133] = {0};
    Script_serialize(result_2, result_2_serialized);
    mu_assert("Error: script_add doesn't work", memcmp(result_2_serialized, want_5, 133) == 0);
    Script_free(script_3);
    Script_free(script_4);
    Script_free(result_2);
    return 0;
}

static char* test_Script_evaluate() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, HEX);
    S256Field* test_z = S256Field_init(test_Z);

    Command cmd_1;
    cmd_1.data[0] = 0x76;
    cmd_1.data_len = 1;
    Command cmd_2;
    cmd_2.data[0] = 0x76;
    cmd_2.data_len = 1;
    Command cmd_3;
    cmd_3.data[0] = 0x95;
    cmd_3.data_len = 1;
    Command cmd_4;
    cmd_4.data[0] = 0x93;
    cmd_4.data_len = 1;
    Command cmd_5;
    cmd_5.data[0] = 0x56;
    cmd_5.data_len = 1;
    Command cmd_6;
    cmd_6.data[0] = 0x87;
    cmd_6.data_len = 1;
    Command cmd_7;
    cmd_7.data[0] = 0x52;
    cmd_7.data_len = 1;

    Command cmds_1[6] = {cmd_1, cmd_2, cmd_3, cmd_4, cmd_5, cmd_6};
    Script* script_1 = Script_init();
    Script_set_cmds(script_1, cmds_1, 6);
    Command cmds_2[1] = {cmd_7};
    Script* script_2 = Script_init();
    Script_set_cmds(script_2, cmds_2, 1);
    Script* combined_script_1 = Script_add(script_2, script_1);
    size_t worked_2 = Script_evaluate(combined_script_1, test_z);
    mu_assert("Error: Script_evaluate doesn't work", worked_2);
    Script_free(script_1);
    Script_free(script_2);
    Script_free(combined_script_1);

    Command cmd_8;
    cmd_8.data[0] = 0x6e;
    cmd_8.data_len = 1;
    Command cmd_9;
    cmd_9.data[0] = 0x87;
    cmd_9.data_len = 1;
    Command cmd_10;
    cmd_10.data[0] = 0x91;
    cmd_10.data_len = 1;
    Command cmd_11;
    cmd_11.data[0] = 0x69;
    cmd_11.data_len = 1;
    Command cmd_12;
    cmd_12.data[0] = 0xa7;
    cmd_12.data_len = 1;
    Command cmd_13;
    cmd_13.data[0] = 0x7c;
    cmd_13.data_len = 1;
    Command cmd_14;
    cmd_14.data[0] = 0xa7;
    cmd_14.data_len = 1;
    Command cmd_15;
    cmd_15.data[0] = 0x87;
    cmd_15.data_len = 1;

    Command cmds_3[8] = {cmd_8, cmd_9, cmd_10, cmd_11, cmd_12, cmd_13, cmd_14, cmd_15};
    Script* scriptpubkey = Script_init();
    Script_set_cmds(scriptpubkey, cmds_3, 8);
    uint8_t c1[320] = {0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x33, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x0a, 0x0a, 0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x2f, 0x57, 0x69, 0x64, 0x74, 0x68, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x33, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x34, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x20, 0x35, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x20, 0x36, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x53, 0x70, 0x61, 0x63, 0x65, 0x20, 0x37, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x38, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x42, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x38, 0x3e, 0x3e, 0x0a, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x0a, 0xff, 0xd8, 0xff, 0xfe, 0x00, 0x24, 0x53, 0x48, 0x41, 0x2d, 0x31, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x61, 0x64, 0x21, 0x21, 0x21, 0x21, 0x21, 0x85, 0x2f, 0xec, 0x09, 0x23, 0x39, 0x75, 0x9c, 0x39, 0xb1, 0xa1, 0xc6, 0x3c, 0x4c, 0x97, 0xe1, 0xff, 0xfe, 0x01, 0x7f, 0x46, 0xdc, 0x93, 0xa6, 0xb6, 0x7e, 0x01, 0x3b, 0x02, 0x9a, 0xaa, 0x1d, 0xb2, 0x56, 0x0b, 0x45, 0xca, 0x67, 0xd6, 0x88, 0xc7, 0xf8, 0x4b, 0x8c, 0x4c, 0x79, 0x1f, 0xe0, 0x2b, 0x3d, 0xf6, 0x14, 0xf8, 0x6d, 0xb1, 0x69, 0x09, 0x01, 0xc5, 0x6b, 0x45, 0xc1, 0x53, 0x0a, 0xfe, 0xdf, 0xb7, 0x60, 0x38, 0xe9, 0x72, 0x72, 0x2f, 0xe7, 0xad, 0x72, 0x8f, 0x0e, 0x49, 0x04, 0xe0, 0x46, 0xc2, 0x30, 0x57, 0x0f, 0xe9, 0xd4, 0x13, 0x98, 0xab, 0xe1, 0x2e, 0xf5, 0xbc, 0x94, 0x2b, 0xe3, 0x35, 0x42, 0xa4, 0x80, 0x2d, 0x98, 0xb5, 0xd7, 0x0f, 0x2a, 0x33, 0x2e, 0xc3, 0x7f, 0xac, 0x35, 0x14, 0xe7, 0x4d, 0xdc, 0x0f, 0x2c, 0xc1, 0xa8, 0x74, 0xcd, 0x0c, 0x78, 0x30, 0x5a, 0x21, 0x56, 0x64, 0x61, 0x30, 0x97, 0x89, 0x60, 0x6b, 0xd0, 0xbf, 0x3f, 0x98, 0xcd, 0xa8, 0x04, 0x46, 0x29, 0xa1};
    uint8_t c2[320] = {0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x33, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x0a, 0x0a, 0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x2f, 0x57, 0x69, 0x64, 0x74, 0x68, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x33, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x34, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x20, 0x35, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x20, 0x36, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x53, 0x70, 0x61, 0x63, 0x65, 0x20, 0x37, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x38, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x42, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x38, 0x3e, 0x3e, 0x0a, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x0a, 0xff, 0xd8, 0xff, 0xfe, 0x00, 0x24, 0x53, 0x48, 0x41, 0x2d, 0x31, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x61, 0x64, 0x21, 0x21, 0x21, 0x21, 0x21, 0x85, 0x2f, 0xec, 0x09, 0x23, 0x39, 0x75, 0x9c, 0x39, 0xb1, 0xa1, 0xc6, 0x3c, 0x4c, 0x97, 0xe1, 0xff, 0xfe, 0x01, 0x73, 0x46, 0xdc, 0x91, 0x66, 0xb6, 0x7e, 0x11, 0x8f, 0x02, 0x9a, 0xb6, 0x21, 0xb2, 0x56, 0x0f, 0xf9, 0xca, 0x67, 0xcc, 0xa8, 0xc7, 0xf8, 0x5b, 0xa8, 0x4c, 0x79, 0x03, 0x0c, 0x2b, 0x3d, 0xe2, 0x18, 0xf8, 0x6d, 0xb3, 0xa9, 0x09, 0x01, 0xd5, 0xdf, 0x45, 0xc1, 0x4f, 0x26, 0xfe, 0xdf, 0xb3, 0xdc, 0x38, 0xe9, 0x6a, 0xc2, 0x2f, 0xe7, 0xbd, 0x72, 0x8f, 0x0e, 0x45, 0xbc, 0xe0, 0x46, 0xd2, 0x3c, 0x57, 0x0f, 0xeb, 0x14, 0x13, 0x98, 0xbb, 0x55, 0x2e, 0xf5, 0xa0, 0xa8, 0x2b, 0xe3, 0x31, 0xfe, 0xa4, 0x80, 0x37, 0xb8, 0xb5, 0xd7, 0x1f, 0x0e, 0x33, 0x2e, 0xdf, 0x93, 0xac, 0x35, 0x00, 0xeb, 0x4d, 0xdc, 0x0d, 0xec, 0xc1, 0xa8, 0x64, 0x79, 0x0c, 0x78, 0x2c, 0x76, 0x21, 0x56, 0x60, 0xdd, 0x30, 0x97, 0x91, 0xd0, 0x6b, 0xd0, 0xaf, 0x3f, 0x98, 0xcd, 0xa4, 0xbc, 0x46, 0x29, 0xb1};
    Command cmd_c1;
    memcpy(cmd_c1.data, c1, 320);
    cmd_c1.data_len = 320;
    Command cmd_c2;
    memcpy(cmd_c2.data, c2, 320);
    cmd_c2.data_len = 320;
    Command cmds_4[2] = {cmd_c1, cmd_c2};
    Script* scriptsig = Script_init();
    Script_set_cmds(scriptsig, cmds_4, 2);
    Script* combined_script_2 = Script_add(scriptsig, scriptpubkey);
    size_t worked_3 = Script_evaluate(combined_script_2, test_z);
    mu_assert("Error: Script_evaluate doesn't work", worked_3);
    Script_free(scriptpubkey);
    Script_free(scriptsig);
    Script_free(combined_script_2);
    S256Field_free(test_z);
    return 0;
}

static char* test_is_p2pkh_script_pubkey() {
    uint8_t script_pubkey_1[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x28, 0x5f, 0x3f, 0x9a, 0x7a, 0x6d, 0x5c, 0x1e, 0x52, 0x2e, 0x8e, 0x4f, 0x4c, 0x3d, 0x6a, 0x8c, 0x7f, 0x92, 0x3f, 0x88, 0xac};
    Script* script_pubkey1 = Script_parse(script_pubkey_1);
    mu_assert("Error: is_p2pkh_script_pubkey doesn't work", is_p2pkh_script_pubkey(script_pubkey1));
    uint8_t script_pubkey_2[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x28, 0x5f, 0x3f, 0x9a, 0x7a, 0x6d, 0x5c, 0x1e, 0x52, 0x2e, 0x8e, 0x4f, 0x4c, 0x3d, 0x6a, 0x8c, 0x7f, 0x92, 0x3f, 0x89, 0xac};
    Script* script_pubkey2 = Script_parse(script_pubkey_2);
    mu_assert("Error: is_p2pkh_script_pubkey doesn't work", !is_p2pkh_script_pubkey(script_pubkey2));
    Script_free(script_pubkey1);
    Script_free(script_pubkey2);
    return 0;
}

static char* test_is_p2sh_script_pubkey() {
    uint8_t script_pubkey_1[24] = {0x17, 0xa9, 0x14, 0x74, 0x6f, 0x8e, 0x92, 0x3a, 0x1b, 0x19, 0x33, 0x7c, 0x8f, 0x1b, 0x0e, 0x7e, 0x3f, 0x74, 0x3b, 0x4b, 0x8a, 0x1f, 0xff, 0x87};
    Script* script_pubkey1 = Script_parse(script_pubkey_1);
    mu_assert("Error: is_p2sh_script_pubkey doesn't work", is_p2sh_script_pubkey(script_pubkey1));
    uint8_t script_pubkey_2[24] = {0x17, 0xa9, 0x14, 0x74, 0x6f, 0x8e, 0x92, 0x3a, 0x1b, 0x19, 0x33, 0x7c, 0x8f, 0x1b, 0x0e, 0x7e, 0x3f, 0x74, 0x3b, 0x4b, 0x8a, 0x1f, 0xff, 0x88};
    Script* script_pubkey2 = Script_parse(script_pubkey_2);
    mu_assert("Error: is_p2sh_script_pubkey doesn't work", !is_p2sh_script_pubkey(script_pubkey2));
    Script_free(script_pubkey1);
    Script_free(script_pubkey2);
    return 0;
}

static char* test_is_p2wpkh_script_pubkey() {
    uint8_t script_pubkey_1[23] = {0x16, 0x00, 0x14, 0x1c, 0x28, 0x5f, 0x3f, 0x9a, 0x7a, 0x6d, 0x5c, 0x1e, 0x52, 0x2e, 0x8e, 0x4f, 0x4c, 0x3d, 0x6a, 0x8c, 0x7f, 0x92, 0x3f};
    Script* script_pubkey1 = Script_parse(script_pubkey_1);
    mu_assert("Error: is_p2wpkh_script_pubkey doesn't work", is_p2wpkh_script_pubkey(script_pubkey1));
    uint8_t script_pubkey_2[22] = {0x15, 0x00, 0x13, 0x1c, 0x28, 0x5f, 0x3f, 0x9a, 0x7a, 0x6d, 0x5c, 0x1e, 0x52, 0x2e, 0x8e, 0x4f, 0x4c, 0x3d, 0x6a, 0x8c, 0x7f, 0x92};
    Script* script_pubkey2 = Script_parse(script_pubkey_2);
    mu_assert("Error: is_p2wpkh_script_pubkey doesn't work", !is_p2wpkh_script_pubkey(script_pubkey2));
    Script_free(script_pubkey1);
    Script_free(script_pubkey2);
    return 0;
}

static char* test_p2pk() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    uint8_t sec[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    uint8_t sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    Command cmd_pubkey;
    memcpy(cmd_pubkey.data, sec, 65);
    cmd_pubkey.data_len = 65;
    Command cmd_sig;
    memcpy(cmd_sig.data, sig, 72);
    cmd_sig.data_len = 72;
    Command cmd;
    cmd.data[0] = 0xac;
    cmd.data_len = 1;
    Command cmds_pubkey[2] = {cmd_pubkey, cmd};
    Script* script_pubkey = Script_init();
    Script_set_cmds(script_pubkey, cmds_pubkey, 2);
    Command cmds_sig[1] = {cmd_sig};
    Script* script_sig = Script_init();
    Script_set_cmds(script_sig, cmds_sig, 1);
    Script* combined_script = Script_add(script_sig, script_pubkey);
    size_t worked = Script_evaluate(combined_script, test_z);
    mu_assert("Error: Script_evaluate doesn't work", worked);
    Script_free(script_sig);
    Script_free(script_pubkey);
    Script_free(combined_script);
    S256Field_free(test_z);
    return 0;
}

static char* test_p2pkh() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    uint8_t hash[20] = {0xe2, 0x95, 0x1e, 0x00, 0x7b, 0x83, 0x4e, 0xb6, 0x1e, 0x99, 0x5d, 0xe8, 0x12, 0x2b, 0x6d, 0x3a, 0xfe, 0xce, 0xeb, 0x42};
    uint8_t sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    uint8_t pubkey[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    Command cmd_opdup;
    cmd_opdup.data[0] = 0x76;
    cmd_opdup.data_len = 1;
    Command cmd_ophash160;
    cmd_ophash160.data[0] = 0xa9;
    cmd_ophash160.data_len = 1;
    Command cmd_hash;
    memcpy(cmd_hash.data, hash, 20);
    cmd_hash.data_len = 20;
    Command cmd_opequalverify;
    cmd_opequalverify.data[0] = 0x88;
    cmd_opequalverify.data_len = 1;
    Command cmd_opchecksig;
    cmd_opchecksig.data[0] = 0xac;
    cmd_opchecksig.data_len = 1;
    Command cmds_pubkey[5] = {cmd_opdup, cmd_ophash160, cmd_hash, cmd_opequalverify, cmd_opchecksig};
    Script* scriptpubkey = Script_init();
    Script_set_cmds(scriptpubkey, cmds_pubkey, 5);
    Command cmd_sig;
    memcpy(cmd_sig.data, sig, 72);
    cmd_sig.data_len = 72;
    Command cmd_pubkey;
    memcpy(cmd_pubkey.data, pubkey, 65);
    cmd_pubkey.data_len = 65;
    Command cmds_sig[2] = {cmd_sig, cmd_pubkey};
    Script* scriptsig = Script_init();
    Script_set_cmds(scriptsig, cmds_sig, 2);
    Script* combined_script = Script_add(scriptsig, scriptpubkey);
    bool worked = Script_evaluate(combined_script, test_z);
    mu_assert("Error: Script_evaluate doesn't work", worked);
    Script_free(scriptpubkey);
    Script_free(scriptsig);
    Script_free(combined_script);
    S256Field_free(test_z);
    return 0;
}

static char* test_find_differences() {
    const char* s1 = "0100000001c228021e1fee6f158cc506edea6bad7ffa421dd14fb7fd7e01c50cc9693e8dbe02000000fdfe0000483045022100c679944ff8f20373685e1122b581f64752c1d22c67f6f3ae26333aa9c3f43d730220793233401f87f640f9c39207349ffef42d0e27046755263c0a69c436ab07febc01483045022100eadc1c6e72f241c3e076a7109b8053db53987f3fcc99e3f88fc4e52dbfd5f3a202201f02cbff194c41e6f8da762e024a7ab85c1b1616b74720f13283043e9e99dab8014c69522102b0c7be446b92624112f3c7d4ffc214921c74c1cb891bf945c49fbe5981ee026b21039021c9391e328e0cb3b61ba05dcc5e122ab234e55d1502e59b10d8f588aea4632102f3bd8f64363066f35968bd82ed9c6e8afecbd6136311bb51e91204f614144e9b53ffffffff05a08601000000000017a914081fbb6ec9d83104367eb1a6a59e2a92417d79298700350c00000000001976a914677345c7376dfda2c52ad9b6a153b643b6409a3788acc7f341160000000017a914234c15756b9599314c9299340eaabab7f1810d8287c02709000000000017a91469be3ca6195efcab5194e1530164ec47637d44308740420f00000000001976a91487fadba66b9e48c0c8082f33107fdb01970eb80388ac0000000000";
    const char* s2 = "0100000001c228021e1fee6f158cc506edea6bad7ffa421dd14fb7fd7e01c50cc9693e8dbe02000000fdfe0000483045022100c679944ff8f20373685e1122b581f64752c1d22c67f6f3ae26333aa9c3f43d730220793233401f87f640f9c39207349ffef42d0e27046755263c0a69c436ab07febc01483045022100eadc1c6e72f241c3e076a7109b8053db53987f3fcc99e3f88fc4e52dbfd5f3a202201f02cbff194c41e6f8da762e024a7ab85c1b1616b74720f13283043e9e99dab8014c69522102b0c7be446b92624112f3c7d4ffc214921c74c1cb891bf945c49fbe5981ee026b21039021c9391e328e0cb3b61ba05dcc5e122ab234e55d1502e59b10d8f588aea4632102f3bd8f64363066f35968bd82ed9c6e8afecbd6136311bb51e91204f614144e9b53aeffffffff05a08601000000000017a914081fbb6ec9d83104367eb1a6a59e2a92417d79298700350c00000000001976a914677345c7376dfda2c52ad9b6a153b643b6409a3788acc7f341160000000017a914234c15756b9599314c9299340eaabab7f1810d8287c02709000000000017a91469be3ca6195efcab5194e1530164ec47637d44308740420f00000000001976a91487fadba66b9e48c0c8082f33107fdb01970eb80388ac00000000";
    find_differences(s1, s2);
    return 0;
}

static char* test_verify_p2pkh() {
    uint8_t raw_tx_1[32] = {0x45, 0x2c, 0x62, 0x9d, 0x67, 0xe4, 0x1b, 0xae, 0xc3, 0xac, 0x6f, 0x04, 0xfe, 0x74, 0x4b, 0x4b, 0x96, 0x17, 0xf8, 0xf8, 0x59, 0xc6, 0x3b, 0x30, 0x02, 0xf8, 0x68, 0x4e, 0x7a, 0x4f, 0xee, 0x03};
    Tx* tx_1 = fetch(raw_tx_1, false);
    size_t result_1 = Tx_verify(tx_1);
    mu_assert("Error: Tx_verify doesn't work", result_1 == 1);
    Tx_free(tx_1);

    uint8_t raw_tx_2[32] = {0x54, 0x18, 0x09, 0x9c, 0xc7, 0x55, 0xcb, 0x9d, 0xd3, 0xeb, 0xc6, 0xcf, 0x1a, 0x78, 0x88, 0xad, 0x53, 0xa1, 0xa3, 0xbe, 0xb5, 0xa0, 0x25, 0xbc, 0xe8, 0x9e, 0xb1, 0xbf, 0x7f, 0x16, 0x50, 0xa2};
    Tx* tx_2 = fetch(raw_tx_2, true);
    size_t result_2 = Tx_verify(tx_2);
    mu_assert("Error: Tx_verify doesn't work", result_2 == 1);
    Tx_free(tx_2);
    return 0;
}

static char* test_verify_p2sh() {
    uint8_t raw_tx[32] = {0x46, 0xdf, 0x1a, 0x94, 0x84, 0xd0, 0xa8, 0x1d, 0x03, 0xce, 0x0e, 0xe5, 0x43, 0xab, 0x6e, 0x1a, 0x23, 0xed, 0x06, 0x17, 0x5c, 0x10, 0x4a, 0x17, 0x82, 0x68, 0xfa, 0xd3, 0x81, 0x21, 0x6c, 0x2b};
    Tx* tx = fetch(raw_tx, false);
    size_t result = Tx_verify(tx);
    mu_assert("Error: Tx_verify doesn't work", result == 1);
    Tx_free(tx);
    return 0;
}

static char* test_signing_transaction() {
    uint8_t raw_tx[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* transaction = Tx_parse(raw_tx, false);
    uint8_t z_raw[32] = {0};
    sig_hash(transaction, 0, z_raw, NULL);
    char z_hex[65];
    byte_array_to_hex_string(z_raw, 32, z_hex);
    mpz_t Z;
    mpz_init_set_str(Z, z_hex, HEX);
    S256Field* z = S256Field_init(Z);
    mpz_t secret;
    mpz_init_set_ui(secret, 8675309);
    PrivateKey* private_key = PrivateKey_init(secret);
    Signature* signature = PrivateKey_sign(private_key, z);
    uint8_t der[71] = {0};
    Signature_der(signature, der);
    uint8_t sighash_all[1] = {0};
    int_to_little_endian(SIGHASH_ALL, sighash_all, 1);
    der[70] = sighash_all[0];
    Command sig_cmd;
    memcpy(sig_cmd.data, der, 71);
    sig_cmd.data_len = 71;
    uint8_t sec[33] = {0};
    S256Point_sec_compressed(private_key->point, sec);
    Command sec_cmd;
    memcpy(sec_cmd.data, sec, 33);
    sec_cmd.data_len = 33;
    Command cmds[2] = {sig_cmd, sec_cmd};
    Script* script_sig = Script_init();
    Script_set_cmds(script_sig, cmds, 2);
    Script_deep_copy(transaction->tx_ins[0]->script_sig, script_sig);
    uint8_t result[225] = {0};
    Tx_serialize(transaction, result);
    uint8_t expected_result[225] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x7d, 0xb2, 0x40, 0x2a, 0x33, 0x11, 0xa3, 0xb8, 0x45, 0xb0, 0x38, 0x88, 0x5e, 0x3d, 0xd8, 0x89, 0xc0, 0x81, 0x26, 0xa8, 0x57, 0x0f, 0x26, 0xa8, 0x44, 0xe3, 0xe4, 0x04, 0x9c, 0x48, 0x2a, 0x11, 0x02, 0x20, 0x10, 0x17, 0x8c, 0xdc, 0xa4, 0x12, 0x9e, 0xac, 0xbe, 0xab, 0x7c, 0x44, 0x64, 0x8b, 0xf5, 0xac, 0x1f, 0x9c, 0xac, 0x21, 0x7c, 0xd6, 0x09, 0xd2, 0x16, 0xec, 0x2e, 0xbc, 0x8d, 0x24, 0x2c, 0x0a, 0x01, 0x21, 0x03, 0x93, 0x55, 0x81, 0xe5, 0x2c, 0x35, 0x4c, 0xd2, 0xf4, 0x84, 0xfe, 0x8e, 0xd8, 0x3a, 0xf7, 0xa3, 0x09, 0x70, 0x05, 0xb2, 0xf9, 0xc6, 0x0b, 0xff, 0x71, 0xd3, 0x5b, 0xd7, 0x95, 0xf5, 0x4b, 0x67, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    mu_assert("Error: signing_transaction doesn't work", memcmp(result, expected_result, 225) == 0);
    Tx_free(transaction);
    S256Field_free(z);
    PrivateKey_free(private_key);
    Signature_free(signature);
    Script_free(script_sig);
    return 0;
}

static char* test_sign_input() {
    mpz_t secret;
    mpz_init_set_ui(secret, 8675309);
    PrivateKey* private_key = PrivateKey_init(secret);
    uint8_t raw_tx[119] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x99, 0xa2, 0x43, 0x08, 0x08, 0x0a, 0xb2, 0x6e, 0x6f, 0xb6, 0x5c, 0x4e, 0xcc, 0xfa, 0xdf, 0x76, 0x74, 0x9b, 0xb5, 0xbf, 0xa8, 0xcb, 0x08, 0xf2, 0x91, 0x32, 0x0b, 0x3c, 0x21, 0xe5, 0x6f, 0x0d, 0x0d, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x40, 0x8a, 0xf7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xd5, 0x2a, 0xd7, 0xca, 0x9b, 0x3d, 0x09, 0x6a, 0x38, 0xe7, 0x52, 0xc2, 0x01, 0x8e, 0x6f, 0xbc, 0x40, 0xcd, 0xf2, 0x6f, 0x88, 0xac, 0x80, 0x96, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x50, 0x7b, 0x27, 0x41, 0x1c, 0xcf, 0x7f, 0x16, 0xf1, 0x02, 0x97, 0xde, 0x6c, 0xef, 0x3f, 0x29, 0x16, 0x23, 0xed, 0xdf, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* tx = Tx_parse(raw_tx, true);
    size_t result = sign_input(tx, 0, private_key);
    mu_assert("Error: sign_input doesn't work", result == 1);
    uint8_t want[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x99, 0xa2, 0x43, 0x08, 0x08, 0x0a, 0xb2, 0x6e, 0x6f, 0xb6, 0x5c, 0x4e, 0xcc, 0xfa, 0xdf, 0x76, 0x74, 0x9b, 0xb5, 0xbf, 0xa8, 0xcb, 0x08, 0xf2, 0x91, 0x32, 0x0b, 0x3c, 0x21, 0xe5, 0x6f, 0x0d, 0x0d, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0x8e, 0xd4, 0x6a, 0xa2, 0xcf, 0x12, 0xd6, 0xd8, 0x10, 0x65, 0xbf, 0xab, 0xe9, 0x03, 0x67, 0x01, 0x65, 0xb5, 0x38, 0xf6, 0x5e, 0xe9, 0xa3, 0x38, 0x5e, 0x63, 0x27, 0xd8, 0x0c, 0x66, 0xd3, 0xb5, 0x02, 0x20, 0x31, 0x24, 0xf8, 0x04, 0x41, 0x05, 0x27, 0x49, 0x73, 0x29, 0xec, 0x47, 0x15, 0xe1, 0x85, 0x58, 0x08, 0x2d, 0x48, 0x9b, 0x21, 0x86, 0x77, 0xbd, 0x02, 0x9e, 0x7f, 0xa3, 0x06, 0xa7, 0x22, 0x36, 0x01, 0x21, 0x03, 0x93, 0x55, 0x81, 0xe5, 0x2c, 0x35, 0x4c, 0xd2, 0xf4, 0x84, 0xfe, 0x8e, 0xd8, 0x3a, 0xf7, 0xa3, 0x09, 0x70, 0x05, 0xb2, 0xf9, 0xc6, 0x0b, 0xff, 0x71, 0xd3, 0x5b, 0xd7, 0x95, 0xf5, 0x4b, 0x67, 0xff, 0xff, 0xff, 0xff, 0x02, 0x40, 0x8a, 0xf7, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xd5, 0x2a, 0xd7, 0xca, 0x9b, 0x3d, 0x09, 0x6a, 0x38, 0xe7, 0x52, 0xc2, 0x01, 0x8e, 0x6f, 0xbc, 0x40, 0xcd, 0xf2, 0x6f, 0x88, 0xac, 0x80, 0x96, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x50, 0x7b, 0x27, 0x41, 0x1c, 0xcf, 0x7f, 0x16, 0xf1, 0x02, 0x97, 0xde, 0x6c, 0xef, 0x3f, 0x29, 0x16, 0x23, 0xed, 0xdf, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    uint8_t tx_serialized[226] = {0};
    Tx_serialize(tx, tx_serialized);
    mu_assert("Error: sign_input doesn't work", memcmp(tx_serialized, want, 226) == 0);
    PrivateKey_free(private_key);
    Tx_free(tx);
    return 0;
}

static char* test_create_real_transaciton() {
    uint8_t prev_tx[32] = {0xb7, 0xcf, 0xed, 0x48, 0xcb, 0xf5, 0x60, 0x27, 0x89, 0x9a, 0x4c, 0x18, 0x85, 0xec, 0x14, 0xea, 0x65, 0x2b, 0x75, 0xaa, 0xde, 0xb4, 0x00, 0xf8, 0x2e, 0x30, 0x80, 0x8c, 0x64, 0xaf, 0x35, 0x81};
    uint32_t prev_index = 0;
    char* target_address = "1CgvQuEBc7FU1QVWDL3cMF5bG5w3QRKsYt";
    uint64_t target_amount = 5000;
    char* change_address = "1HqC6HfkvV8rXsAiKYaW6bFEoU4U8a17rH";
    uint64_t change_amount = 2000;
    mpz_t secret_num;
    char* private_key = "buddia";
    hash_to_mpz_t((const uint8_t*)private_key, 6, secret_num);
    PrivateKey* priv = PrivateKey_init(secret_num);
    Script* script_sig = Script_init();
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, 0xffffffff);
    printf("txin: ");
    TxIn_toString(tx_in);
    TxIn* tx_ins[1] = {tx_in};
    uint8_t target_h160[20] = {0};
    decode_base58((const char*)target_address, target_h160);
    printf("target_h160: ");
    for (int i = 0; i < 20; i++) {
        printf("%02x", target_h160[i]);
    }
    printf("\n");
    Script* target_script = p2pkh_script(target_h160);
    printf("target_script: ");
    Script_toString(target_script);
    TxOut* target_txout = TxOut_init(target_amount, target_script);
    printf("target_txout: ");
    TxOut_toString(target_txout);
    uint8_t change_h160[20] = {0};
    decode_base58((const char*)change_address, change_h160);
    printf("change_h160: ");
    for (int i = 0; i < 20; i++) {
        printf("%02x", change_h160[i]);
    }
    printf("\n");
    Script* change_script = p2pkh_script(change_h160);
    printf("change_script: ");
    Script_toString(change_script);
    TxOut* change_txout = TxOut_init(change_amount, change_script);
    printf("change_txout: ");
    TxOut_toString(change_txout);
    TxOut* tx_outs[2] = {target_txout, change_txout};
    Tx* tx = Tx_init(1, 1, tx_ins, 2, tx_outs, 0, false, false);
    bool result = sign_input(tx, 0, priv);
    printf("result: %d\n", result);
    uint8_t serialized[226] = {0};
    Tx_serialize(tx, serialized);
    printf("serialized: ");
    for (int i = 0; i < 226; i++) {
        printf("%02x", serialized[i]);
    }
    printf("\n");
    uint8_t expected_result[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x35, 0xaf, 0x64, 0x8c, 0x80, 0x30, 0x2e, 0xf8, 0x00, 0xb4, 0xde, 0xaa, 0x75, 0x2b, 0x65, 0xea, 0x14, 0xec, 0x85, 0x18, 0x4c, 0x9a, 0x89, 0x27, 0x60, 0xf5, 0xcb, 0x48, 0xed, 0xcf, 0xb7, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xa4, 0xf1, 0x76, 0x23, 0xd5, 0x09, 0x80, 0x84, 0xbc, 0x64, 0x5b, 0x60, 0xb1, 0x9d, 0x3a, 0x1d, 0x10, 0x07, 0xaf, 0xdc, 0x7a, 0xab, 0x90, 0x98, 0x45, 0x8b, 0xdc, 0x03, 0xb3, 0x30, 0x13, 0x07, 0x02, 0x20, 0x40, 0xa6, 0xeb, 0x80, 0xe7, 0x17, 0xd6, 0x8f, 0x5d, 0x4d, 0x9d, 0x45, 0xc3, 0xe5, 0x54, 0xda, 0xdf, 0xe5, 0x9d, 0xdf, 0x5d, 0xa3, 0x90, 0xe0, 0x40, 0x26, 0x30, 0xd4, 0xc0, 0xe8, 0x62, 0x23, 0x01, 0x21, 0x03, 0xc0, 0xdf, 0x4f, 0x18, 0xb1, 0x7d, 0x4b, 0x12, 0x3e, 0x5e, 0x8b, 0x0b, 0xaa, 0xe7, 0x9c, 0xc6, 0xfb, 0xa8, 0xf2, 0x78, 0x38, 0xd9, 0xa8, 0xa9, 0xef, 0xb1, 0x65, 0xbf, 0x5e, 0x20, 0x71, 0x86, 0xff, 0xff, 0xff, 0xff, 0x02, 0x88, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x80, 0x36, 0x31, 0x39, 0xc8, 0x40, 0xaa, 0xeb, 0xe2, 0xcd, 0x2e, 0x2c, 0x35, 0x5e, 0x25, 0x9f, 0x43, 0x46, 0x1f, 0x6c, 0x88, 0xac, 0xd0, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xb8, 0x9f, 0x3c, 0xb5, 0x55, 0x5f, 0xa0, 0xdb, 0xb5, 0xe1, 0x43, 0x9b, 0x05, 0x07, 0x95, 0xf3, 0x1d, 0x10, 0x3b, 0x2e, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    mu_assert("Error: create_transaction doesn't work", memcmp(serialized, expected_result, 226) == 0);
    PrivateKey_free(priv);
    TxIn_free(tx_in);
    TxOut_free(target_txout);
    TxOut_free(change_txout);
    free(tx);
    return 0;
}

static char* test_create_testnet_transaction() {
    const char* target_address = "miKegze5FQNCnGw6PKyqUbYUeBa4x2hFeM";
    uint8_t prev_tx[32] = {0x75, 0xa1, 0xc4, 0xbc, 0x67, 0x1f, 0x55, 0xf6, 0x26, 0xdd, 0xa1, 0x07, 0x4c, 0x77, 0x25, 0x99, 0x1e, 0x6f, 0x68, 0xb8, 0xfc, 0xef, 0xcf, 0xca, 0x7b, 0x64, 0x40, 0x5c, 0xa3, 0xb4, 0x5f, 0x1c};
    int prev_index = 1;
    uint64_t target_amount = 1000000;
    uint64_t change_amount = 899999;
    const char* change_address = "mzx5YhAH9kNHtcN481u6WkjeHjYtVeKVh2";
    mpz_t secret;
    mpz_init_set_ui(secret, 8675309);
    PrivateKey* private_key = PrivateKey_init(secret);
    Script* script_sig = Script_init();
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, 0xffffffff);
    uint8_t target_h160[20] = {0};
    decode_base58(target_address, target_h160);
    Script* target_script = p2pkh_script(target_h160);
    TxOut* target_tx_out = TxOut_init(target_amount, target_script);
    uint8_t change_h160[20] = {0};
    decode_base58(change_address, change_h160);
    Script* change_script = p2pkh_script(change_h160);
    TxOut* change_tx_out = TxOut_init(change_amount, change_script);
    TxIn* inputs[1] = {tx_in};
    TxOut* outputs[2] = {target_tx_out, change_tx_out};
    Tx* tx = Tx_init(1, 1, inputs, 2, outputs, 0, true, false);
    size_t result = sign_input(tx, 0, private_key);
    mu_assert("Error: create_transaction doesn't work", result == 1);
    uint8_t tx_serialized[226] = {0};
    Tx_serialize(tx, tx_serialized);
    uint8_t expected_result[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x1c, 0x5f, 0xb4, 0xa3, 0x5c, 0x40, 0x64, 0x7b, 0xca, 0xcf, 0xef, 0xfc, 0xb8, 0x68, 0x6f, 0x1e, 0x99, 0x25, 0x77, 0x4c, 0x07, 0xa1, 0xdd, 0x26, 0xf6, 0x55, 0x1f, 0x67, 0xbc, 0xc4, 0xa1, 0x75, 0x01, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xa0, 0x8e, 0xbb, 0x92, 0x42, 0x2b, 0x35, 0x99, 0xa2, 0xd2, 0xfc, 0xda, 0xa1, 0x1f, 0x8f, 0x80, 0x7a, 0x66, 0xcc, 0xf3, 0x3e, 0x7f, 0x4a, 0x9f, 0xf0, 0xa3, 0xc5, 0x1f, 0x1b, 0x1e, 0xc5, 0xdd, 0x02, 0x20, 0x5e, 0xd2, 0x1d, 0xfe, 0xde, 0x59, 0x25, 0x36, 0x2b, 0x8d, 0x98, 0x33, 0xe9, 0x08, 0x64, 0x6c, 0x54, 0xbe, 0x7a, 0xc6, 0x66, 0x4e, 0x31, 0x65, 0x01, 0x59, 0xe8, 0xf6, 0x9b, 0x6c, 0xa5, 0x39, 0x01, 0x21, 0x03, 0x93, 0x55, 0x81, 0xe5, 0x2c, 0x35, 0x4c, 0xd2, 0xf4, 0x84, 0xfe, 0x8e, 0xd8, 0x3a, 0xf7, 0xa3, 0x09, 0x70, 0x05, 0xb2, 0xf9, 0xc6, 0x0b, 0xff, 0x71, 0xd3, 0x5b, 0xd7, 0x95, 0xf5, 0x4b, 0x67, 0xff, 0xff, 0xff, 0xff, 0x02, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1e, 0xc5, 0x1b, 0x36, 0x54, 0xc1, 0xf1, 0xd0, 0xf4, 0x92, 0x9d, 0x11, 0xa1, 0xf7, 0x02, 0x93, 0x7e, 0xaf, 0x50, 0xc8, 0x88, 0xac, 0x9f, 0xbb, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xd5, 0x2a, 0xd7, 0xca, 0x9b, 0x3d, 0x09, 0x6a, 0x38, 0xe7, 0x52, 0xc2, 0x01, 0x8e, 0x6f, 0xbc, 0x40, 0xcd, 0xf2, 0x6f, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    char result_hex[452] = {0};
    byte_array_to_hex_string(tx_serialized, 226, result_hex);
    printf("%s\n", result_hex);
    mu_assert("Error: create_transaction doesn't work", memcmp(tx_serialized, expected_result, 226) == 0);
    PrivateKey_free(private_key);
    TxIn_free(tx_in);
    TxOut_free(target_tx_out);
    TxOut_free(change_tx_out);
    free(tx);

    uint8_t prev_tx_1[32] = {0x11, 0xd0, 0x5c, 0xe7, 0x07, 0xc1, 0x12, 0x02, 0x48, 0x37, 0x0d, 0x1c, 0xbf, 0x55, 0x61, 0xd2, 0x2c, 0x4f, 0x83, 0xae, 0xba, 0x04, 0x36, 0x79, 0x2c, 0x82, 0xe0, 0xbd, 0x57, 0xfe, 0x2a, 0x2f};
    uint8_t prev_tx_2[32] = {0x51, 0xf6, 0x1f, 0x77, 0xbd, 0x06, 0x1b, 0x9a, 0x0d, 0xa6, 0x0d, 0x4b, 0xed, 0xaa, 0xf1, 0xb1, 0xfa, 0xd0, 0xc1, 0x1e, 0x65, 0xfd, 0xc7, 0x44, 0x79, 0x7e, 0xe2, 0x2d, 0x20, 0xb0, 0x3d, 0x15};
    int prev_index_1 = 1;
    int prev_index_2 = 1;
    const char* target_address_1 = "mwJn1YPMq7y5F8J3LkC5Hxg9PHyZ5K4cFv";
    uint64_t target_amount_1 = 4290000;
    mpz_t secret_1;
    mpz_init_set_ui(secret_1, 8675309);
    PrivateKey* private_key_1 = PrivateKey_init(secret_1);
    Script* script_sig_1 = Script_init();
    TxIn* tx_in_1 = TxIn_init(prev_tx_1, prev_index_1, script_sig_1, 0xffffffff);
    Script* script_sig_2 = Script_init();
    TxIn* tx_in_2 = TxIn_init(prev_tx_2, prev_index_2, script_sig_2, 0xffffffff);
    uint8_t target_h160_1[20] = {0};
    decode_base58(target_address_1, target_h160_1);
    Script* target_script_1 = p2pkh_script(target_h160_1);
    TxOut* target_tx_out_1 = TxOut_init(target_amount_1, target_script_1);
    TxIn* inputs_1[2] = {tx_in_1, tx_in_2};
    TxOut* outputs_1[1] = {target_tx_out_1};
    Tx* tx_1 = Tx_init(1, 2, inputs_1, 1, outputs_1, 0, true, false);
    size_t result_1 = sign_input(tx_1, 0, private_key_1);
    size_t result_2 = sign_input(tx_1, 1, private_key_1);
    mu_assert("Error: create_transaction doesn't work", result_1 == 1 && result_2 == 1);
    uint8_t tx_serialized_1[339] = {0};
    Tx_serialize(tx_1, tx_serialized_1);
    uint8_t expected_result_1[339] = {0x01, 0x00, 0x00, 0x00, 0x02, 0x2f, 0x2a, 0xfe, 0x57, 0xbd, 0xe0, 0x82, 0x2c, 0x79, 0x36, 0x04, 0xba, 0xae, 0x83, 0x4f, 0x2c, 0xd2, 0x61, 0x55, 0xbf, 0x1c, 0x0d, 0x37, 0x48, 0x02, 0x12, 0xc1, 0x07, 0xe7, 0x5c, 0xd0, 0x11, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x4c, 0xc5, 0xfe, 0x11, 0xb2, 0xb0, 0x25, 0xf8, 0xfc, 0x9f, 0x60, 0x73, 0xb5, 0xe3, 0x94, 0x28, 0x83, 0xbb, 0xba, 0x26, 0x6b, 0x71, 0x75, 0x10, 0x68, 0xba, 0xde, 0xb8, 0xf1, 0x1f, 0x03, 0x64, 0x02, 0x20, 0x70, 0x17, 0x83, 0x63, 0xf5, 0xde, 0xa4, 0x14, 0x95, 0x81, 0xa4, 0xb9, 0xb9, 0xdb, 0xad, 0x91, 0xec, 0x1f, 0xd9, 0x90, 0xe3, 0xfa, 0x14, 0xf9, 0xde, 0x3c, 0xcb, 0x42, 0x1f, 0xa5, 0xb2, 0x69, 0x01, 0x21, 0x03, 0x93, 0x55, 0x81, 0xe5, 0x2c, 0x35, 0x4c, 0xd2, 0xf4, 0x84, 0xfe, 0x8e, 0xd8, 0x3a, 0xf7, 0xa3, 0x09, 0x70, 0x05, 0xb2, 0xf9, 0xc6, 0x0b, 0xff, 0x71, 0xd3, 0x5b, 0xd7, 0x95, 0xf5, 0x4b, 0x67, 0xff, 0xff, 0xff, 0xff, 0x15, 0x3d, 0xb0, 0x20, 0x2d, 0xe2, 0x7e, 0x79, 0x44, 0xc7, 0xfd, 0x65, 0x1e, 0xc1, 0xd0, 0xfa, 0xb1, 0xf1, 0xaa, 0xed, 0x4b, 0x0d, 0xa6, 0x0d, 0x9a, 0x1b, 0x06, 0xbd, 0x77, 0x1f, 0xf6, 0x51, 0x01, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xb7, 0xa9, 0x38, 0xd4, 0x67, 0x9a, 0xa7, 0x27, 0x1f, 0x0d, 0x32, 0xd8, 0x3b, 0x61, 0xa8, 0x5e, 0xb0, 0x18, 0x0c, 0xf1, 0x26, 0x1d, 0x44, 0xfe, 0xaa, 0xd2, 0x3d, 0xfd, 0x97, 0x99, 0xda, 0xfb, 0x02, 0x20, 0x5f, 0xf2, 0xf3, 0x66, 0xdd, 0xd9, 0x55, 0x5f, 0x71, 0x46, 0x86, 0x1a, 0x82, 0x98, 0xb7, 0x63, 0x6b, 0xe8, 0xb2, 0x92, 0x09, 0x0a, 0x22, 0x4c, 0x5d, 0xc8, 0x42, 0x68, 0x48, 0x0d, 0x8b, 0xe1, 0x01, 0x21, 0x03, 0x93, 0x55, 0x81, 0xe5, 0x2c, 0x35, 0x4c, 0xd2, 0xf4, 0x84, 0xfe, 0x8e, 0xd8, 0x3a, 0xf7, 0xa3, 0x09, 0x70, 0x05, 0xb2, 0xf9, 0xc6, 0x0b, 0xff, 0x71, 0xd3, 0x5b, 0xd7, 0x95, 0xf5, 0x4b, 0x67, 0xff, 0xff, 0xff, 0xff, 0x01, 0xd0, 0x75, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xad, 0x34, 0x6f, 0x8e, 0xb5, 0x7d, 0xee, 0x9a, 0x37, 0x98, 0x17, 0x16, 0xe4, 0x98, 0x12, 0x0a, 0xe8, 0x0e, 0x44, 0xf7, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    mu_assert("Error: create_transaction doesn't work", memcmp(tx_serialized_1, expected_result_1, 339) == 0);
    PrivateKey_free(private_key_1);
    TxIn_free(tx_in_1);
    TxIn_free(tx_in_2);
    TxOut_free(target_tx_out_1);
    free(tx_1);
    return 0;
}

static char* test_Op_checkmultisig() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_4, HEX);
    S256Field* test_z = S256Field_init(test_Z);
    uint8_t sig1[72] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xdc, 0x92, 0x65, 0x5f, 0xe3, 0x70, 0x36, 0xf4, 0x77, 0x56, 0xdb, 0x81, 0x02, 0xe0, 0xd7, 0xd5, 0xe2, 0x8b, 0x3b, 0xeb, 0x83, 0xa8, 0xfe, 0xf4, 0xf5, 0xdc, 0x05, 0x59, 0xbd, 0xdf, 0xb9, 0x4e, 0x02, 0x20, 0x5a, 0x36, 0xd4, 0xe4, 0xe6, 0xc7, 0xfc, 0xd1, 0x66, 0x58, 0xc5, 0x07, 0x83, 0xe0, 0x0c, 0x34, 0x16, 0x09, 0x97, 0x7a, 0xed, 0x3a, 0xd0, 0x09, 0x37, 0xbf, 0x4e, 0xe9, 0x42, 0xa8, 0x99, 0x37, 0x01};
    uint8_t sig2[72] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xda, 0x6b, 0xee, 0x3c, 0x93, 0x76, 0x62, 0x32, 0x07, 0x9a, 0x01, 0x63, 0x9d, 0x07, 0xfa, 0x86, 0x95, 0x98, 0x74, 0x97, 0x29, 0xae, 0x32, 0x3e, 0xab, 0x8e, 0xef, 0x53, 0x57, 0x7d, 0x61, 0x1b, 0x02, 0x20, 0x7b, 0xef, 0x15, 0x42, 0x9d, 0xca, 0xdc, 0xe2, 0x12, 0x1e, 0xa0, 0x7f, 0x23, 0x31, 0x15, 0xc6, 0xf0, 0x90, 0x34, 0xc0, 0xbe, 0x68, 0xdb, 0x99, 0x98, 0x0b, 0x9a, 0x6c, 0x5e, 0x75, 0x40, 0x22, 0x01};
    uint8_t sec1[33] = {0x02, 0x26, 0x26, 0xe9, 0x55, 0xea, 0x6e, 0xa6, 0xd9, 0x88, 0x50, 0xc9, 0x94, 0xf9, 0x10, 0x7b, 0x03, 0x6b, 0x13, 0x34, 0xf1, 0x8c, 0xa8, 0x83, 0x0b, 0xff, 0xf1, 0x29, 0x5d, 0x21, 0xcf, 0xdb, 0x70};
    uint8_t sec2[33] = {0x03, 0xb2, 0x87, 0xea, 0xf1, 0x22, 0xee, 0xa6, 0x90, 0x30, 0xa0, 0xe9, 0xfe, 0xed, 0x09, 0x6b, 0xed, 0x80, 0x45, 0xc8, 0xb9, 0x8b, 0xec, 0x45, 0x3e, 0x1f, 0xfa, 0xc7, 0xfb, 0xdb, 0xd4, 0xbb, 0x71};
    Op* op = Op_init();
    uint8_t zero[1] = {0x00};
    uint8_t two[1] = {0x02};
    push(op, zero, 1);
    push(op, sig1, 72);
    push(op, sig2, 72);
    push(op, two, 1);
    push(op, sec1, 33);
    push(op, sec2, 33);
    push(op, two, 1);
    size_t checkmultisig = Op_checkmultisig(op, test_z);
    mu_assert("Error: Op_checkmultisig doesn't work", checkmultisig);
    int64_t num = decode_num(op->stack[0], 1);
    mu_assert("Error: Op_checkmultisig doesn't work", num == 1);
    Op_free(op);
    S256Field_free(test_z);
    return 0;
}

static char* test_verify_signature_from_transaction() {
    uint8_t modified_tx[260] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x86, 0x82, 0x78, 0xed, 0x6d, 0xdf, 0xb6, 0xc1, 0xed, 0x3a, 0xd5, 0xf8, 0x18, 0x1e, 0xb0, 0xc7, 0xa3, 0x85, 0xaa, 0x08, 0x36, 0xf0, 0x1d, 0x5e, 0x47, 0x89, 0xe6, 0xbd, 0x30, 0x4d, 0x87, 0x22, 0x1a, 0x00, 0x00, 0x00, 0x47, 0x52, 0x21, 0x02, 0x26, 0x26, 0xe9, 0x55, 0xea, 0x6e, 0xa6, 0xd9, 0x88, 0x50, 0xc9, 0x94, 0xf9, 0x10, 0x7b, 0x03, 0x6b, 0x13, 0x34, 0xf1, 0x8c, 0xa8, 0x83, 0x0b, 0xff, 0xf1, 0x29, 0x5d, 0x21, 0xcf, 0xdb, 0x70, 0x21, 0x03, 0xb2, 0x87, 0xea, 0xf1, 0x22, 0xee, 0xa6, 0x90, 0x30, 0xa0, 0xe9, 0xfe, 0xed, 0x09, 0x6b, 0xed, 0x80, 0x45, 0xc8, 0xb9, 0x8b, 0xec, 0x45, 0x3e, 0x1f, 0xfa, 0xc7, 0xfb, 0xdb, 0xd4, 0xbb, 0x71, 0x52, 0xae, 0xff, 0xff, 0xff, 0xff, 0x04, 0xd3, 0xb1, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x90, 0x4a, 0x49, 0x87, 0x8c, 0x0a, 0xdf, 0xc3, 0xaa, 0x05, 0xde, 0x7a, 0xfa, 0xd2, 0xcc, 0x15, 0xf4, 0x83, 0xa5, 0x6a, 0x88, 0xac, 0x7f, 0x40, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x41, 0x83, 0x27, 0xe3, 0xf3, 0xdd, 0xa4, 0xcf, 0x5b, 0x90, 0x89, 0x32, 0x5a, 0x4b, 0x95, 0xab, 0xdf, 0xa0, 0x33, 0x40, 0x88, 0xac, 0x72, 0x2c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0x35, 0x04, 0x2c, 0xfe, 0x9f, 0xc6, 0x6f, 0xd3, 0x5a, 0xc2, 0x22, 0x4e, 0xeb, 0xda, 0xfd, 0x10, 0x28, 0xad, 0x27, 0x88, 0xac, 0xdc, 0x4a, 0xce, 0x02, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x74, 0xd6, 0x91, 0xda, 0x15, 0x74, 0xe6, 0xb3, 0xc1, 0x92, 0xec, 0xfb, 0x52, 0xcc, 0x89, 0x84, 0xee, 0x7b, 0x6c, 0x56, 0x87, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00};
    uint8_t h256[32] = {0};
    hash256(modified_tx, 260, h256);
    char z_hex[64] = {0};
    byte_array_to_hex_string(h256, 32, z_hex);
    mpz_t Z;
    mpz_init_set_str(Z, z_hex, HEX);
    S256Field* z = S256Field_init(Z);
    uint8_t sec[33] = {0x02, 0x26, 0x26, 0xe9, 0x55, 0xea, 0x6e, 0xa6, 0xd9, 0x88, 0x50, 0xc9, 0x94, 0xf9, 0x10, 0x7b, 0x03, 0x6b, 0x13, 0x34, 0xf1, 0x8c, 0xa8, 0x83, 0x0b, 0xff, 0xf1, 0x29, 0x5d, 0x21, 0xcf, 0xdb, 0x70};
    uint8_t der[71] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xdc, 0x92, 0x65, 0x5f, 0xe3, 0x70, 0x36, 0xf4, 0x77, 0x56, 0xdb, 0x81, 0x02, 0xe0, 0xd7, 0xd5, 0xe2, 0x8b, 0x3b, 0xeb, 0x83, 0xa8, 0xfe, 0xf4, 0xf5, 0xdc, 0x05, 0x59, 0xbd, 0xdf, 0xb9, 0x4e, 0x02, 0x20, 0x5a, 0x36, 0xd4, 0xe4, 0xe6, 0xc7, 0xfc, 0xd1, 0x66, 0x58, 0xc5, 0x07, 0x83, 0xe0, 0x0c, 0x34, 0x16, 0x09, 0x97, 0x7a, 0xed, 0x3a, 0xd0, 0x09, 0x37, 0xbf, 0x4e, 0xe9, 0x42, 0xa8, 0x99, 0x37};
    S256Point* point = S256Point_parse_sec(sec);
    Signature* sig = Signature_parse(der);
    bool verified = S256Point_verify(point, z, sig);
    mu_assert("Error: verify_signature_from_transaction doesn't work", verified);
    S256Field_free(z);
    S256Point_free(point);
    Signature_free(sig);

    uint8_t hex_tx[404] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x86, 0x82, 0x78, 0xed, 0x6d, 0xdf, 0xb6, 0xc1, 0xed, 0x3a, 0xd5, 0xf8, 0x18, 0x1e, 0xb0, 0xc7, 0xa3, 0x85, 0xaa, 0x08, 0x36, 0xf0, 0x1d, 0x5e, 0x47, 0x89, 0xe6, 0xbd, 0x30, 0x4d, 0x87, 0x22, 0x1a, 0x00, 0x00, 0x00, 0xdb, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xdc, 0x92, 0x65, 0x5f, 0xe3, 0x70, 0x36, 0xf4, 0x77, 0x56, 0xdb, 0x81, 0x02, 0xe0, 0xd7, 0xd5, 0xe2, 0x8b, 0x3b, 0xeb, 0x83, 0xa8, 0xfe, 0xf4, 0xf5, 0xdc, 0x05, 0x59, 0xbd, 0xdf, 0xb9, 0x4e, 0x02, 0x20, 0x5a, 0x36, 0xd4, 0xe4, 0xe6, 0xc7, 0xfc, 0xd1, 0x66, 0x58, 0xc5, 0x07, 0x83, 0xe0, 0x0c, 0x34, 0x16, 0x09, 0x97, 0x7a, 0xed, 0x3a, 0xd0, 0x09, 0x37, 0xbf, 0x4e, 0xe9, 0x42, 0xa8, 0x99, 0x37, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xda, 0x6b, 0xee, 0x3c, 0x93, 0x76, 0x62, 0x32, 0x07, 0x9a, 0x01, 0x63, 0x9d, 0x07, 0xfa, 0x86, 0x95, 0x98, 0x74, 0x97, 0x29, 0xae, 0x32, 0x3e, 0xab, 0x8e, 0xef, 0x53, 0x57, 0x7d, 0x61, 0x1b, 0x02, 0x20, 0x7b, 0xef, 0x15, 0x42, 0x9d, 0xca, 0xdc, 0xe2, 0x12, 0x1e, 0xa0, 0x7f, 0x23, 0x31, 0x15, 0xc6, 0xf0, 0x90, 0x34, 0xc0, 0xbe, 0x68, 0xdb, 0x99, 0x98, 0x0b, 0x9a, 0x6c, 0x5e, 0x75, 0x40, 0x22, 0x01, 0x47, 0x52, 0x21, 0x02, 0x26, 0x26, 0xe9, 0x55, 0xea, 0x6e, 0xa6, 0xd9, 0x88, 0x50, 0xc9, 0x94, 0xf9, 0x10, 0x7b, 0x03, 0x6b, 0x13, 0x34, 0xf1, 0x8c, 0xa8, 0x83, 0x0b, 0xff, 0xf1, 0x29, 0x5d, 0x21, 0xcf, 0xdb, 0x70, 0x21, 0x03, 0xb2, 0x87, 0xea, 0xf1, 0x22, 0xee, 0xa6, 0x90, 0x30, 0xa0, 0xe9, 0xfe, 0xed, 0x09, 0x6b, 0xed, 0x80, 0x45, 0xc8, 0xb9, 0x8b, 0xec, 0x45, 0x3e, 0x1f, 0xfa, 0xc7, 0xfb, 0xdb, 0xd4, 0xbb, 0x71, 0x52, 0xae, 0xff, 0xff, 0xff, 0xff, 0x04, 0xd3, 0xb1, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x90, 0x4a, 0x49, 0x87, 0x8c, 0x0a, 0xdf, 0xc3, 0xaa, 0x05, 0xde, 0x7a, 0xfa, 0xd2, 0xcc, 0x15, 0xf4, 0x83, 0xa5, 0x6a, 0x88, 0xac, 0x7f, 0x40, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x41, 0x83, 0x27, 0xe3, 0xf3, 0xdd, 0xa4, 0xcf, 0x5b, 0x90, 0x89, 0x32, 0x5a, 0x4b, 0x95, 0xab, 0xdf, 0xa0, 0x33, 0x40, 0x88, 0xac, 0x72, 0x2c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0x35, 0x04, 0x2c, 0xfe, 0x9f, 0xc6, 0x6f, 0xd3, 0x5a, 0xc2, 0x22, 0x4e, 0xeb, 0xda, 0xfd, 0x10, 0x28, 0xad, 0x27, 0x88, 0xac, 0xdc, 0x4a, 0xce, 0x02, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x74, 0xd6, 0x91, 0xda, 0x15, 0x74, 0xe6, 0xb3, 0xc1, 0x92, 0xec, 0xfb, 0x52, 0xcc, 0x89, 0x84, 0xee, 0x7b, 0x6c, 0x56, 0x87, 0x00, 0x00, 0x00, 0x00};
    uint8_t hex_sec[33] = {0x03, 0xb2, 0x87, 0xea, 0xf1, 0x22, 0xee, 0xa6, 0x90, 0x30, 0xa0, 0xe9, 0xfe, 0xed, 0x09, 0x6b, 0xed, 0x80, 0x45, 0xc8, 0xb9, 0x8b, 0xec, 0x45, 0x3e, 0x1f, 0xfa, 0xc7, 0xfb, 0xdb, 0xd4, 0xbb, 0x71};
    uint8_t hex_der[71] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xda, 0x6b, 0xee, 0x3c, 0x93, 0x76, 0x62, 0x32, 0x07, 0x9a, 0x01, 0x63, 0x9d, 0x07, 0xfa, 0x86, 0x95, 0x98, 0x74, 0x97, 0x29, 0xae, 0x32, 0x3e, 0xab, 0x8e, 0xef, 0x53, 0x57, 0x7d, 0x61, 0x1b, 0x02, 0x20, 0x7b, 0xef, 0x15, 0x42, 0x9d, 0xca, 0xdc, 0xe2, 0x12, 0x1e, 0xa0, 0x7f, 0x23, 0x31, 0x15, 0xc6, 0xf0, 0x90, 0x34, 0xc0, 0xbe, 0x68, 0xdb, 0x99, 0x98, 0x0b, 0x9a, 0x6c, 0x5e, 0x75, 0x40, 0x22};
    uint8_t hex_redeem_script[72] = {0x47, 0x52, 0x21, 0x02, 0x26, 0x26, 0xe9, 0x55, 0xea, 0x6e, 0xa6, 0xd9, 0x88, 0x50, 0xc9, 0x94, 0xf9, 0x10, 0x7b, 0x03, 0x6b, 0x13, 0x34, 0xf1, 0x8c, 0xa8, 0x83, 0x0b, 0xff, 0xf1, 0x29, 0x5d, 0x21, 0xcf, 0xdb, 0x70, 0x21, 0x03, 0xb2, 0x87, 0xea, 0xf1, 0x22, 0xee, 0xa6, 0x90, 0x30, 0xa0, 0xe9, 0xfe, 0xed, 0x09, 0x6b, 0xed, 0x80, 0x45, 0xc8, 0xb9, 0x8b, 0xec, 0x45, 0x3e, 0x1f, 0xfa, 0xc7, 0xfb, 0xdb, 0xd4, 0xbb, 0x71, 0x52, 0xae};
    Script* redeem_script = Script_parse(hex_redeem_script);
    Tx* tx_obj = Tx_parse(hex_tx, false);
    uint8_t s[260] = {0};
    int32_t offset = 0;
    int_to_little_endian(tx_obj->version, s, 4);
    offset += 4;
    encode_varint(s + offset, tx_obj->num_inputs);
    offset += 1;
    TxIn* i = TxIn_deep_copy(tx_obj->tx_ins[0]);
    Script_deep_copy(i->script_sig, redeem_script);
    uint8_t i_serialized[112] = {0};
    TxIn_serialize(i, i_serialized);
    memcpy(s + offset, i_serialized, 112);
    offset += 112;
    encode_varint(s + offset, tx_obj->num_outputs);
    offset += 1;
    for (size_t i = 0; i < tx_obj->num_outputs; i++) {
        TxOut* o = TxOut_deep_copy(tx_obj->tx_outs[i]);
        uint64_t o_serialized_length = TxOut_length(o);
        uint8_t o_serialized[o_serialized_length];
        TxOut_serialize(o, o_serialized);
        memcpy(s + offset, o_serialized, o_serialized_length);
        offset += o_serialized_length;
        TxOut_free(o);
    }
    int_to_little_endian(tx_obj->locktime, s + offset, 4);
    offset += 4;
    int_to_little_endian(SIGHASH_ALL, s + offset, 4);
    offset += 4;
    uint8_t h256_1[32] = {0};
    hash256(s, 260, h256_1);
    char z_hex1[64] = {0};
    byte_array_to_hex_string(h256_1, 32, z_hex1);
    mpz_t Z1;
    mpz_init_set_str(Z1, z_hex1, HEX);
    S256Field* z1 = S256Field_init(Z1);
    S256Point* point1 = S256Point_parse_sec(hex_sec);
    Signature* sig1 = Signature_parse(hex_der);
    bool verified1 = S256Point_verify(point1, z1, sig1);
    mu_assert("Error: verify_signature_from_transaction doesn't work", verified1);
    Script_free(redeem_script);
    TxIn_free(i);
    S256Field_free(z1);
    S256Point_free(point1);
    Signature_free(sig1);
    Tx_free(tx_obj);
    return 0;
}

static char* test_get_balance() {
    const char* address = "1HqC6HfkvV8rXsAiKYaW6bFEoU4U8a17rH";
    uint64_t balance = get_balance(address);
    printf("balance: %ld\n", balance);
    // mu_assert("Error: get_balance doesn't work", balance == 10000);

    const char* address2 = "1FQc5LGHMHEN9nwk8A3QY4f8vzj2Zj8U";
    uint64_t balance2 = get_balance(address2);
    mu_assert("Error: get_balance doesn't work", balance2 == 0);
    return 0;
}

static char* test_extract_all_utxo_info() {
    const char* address = "1HqC6HfkvV8rXsAiKYaW6bFEoU4U8a17rH";
    char utxo_response[10000] = {0};
    char **txids = NULL;
    int32_t *vouts = NULL;
    int32_t num_utxos = 0;
    get_utxos(address, utxo_response);
    extract_all_utxo_info(utxo_response, &txids, &vouts, &num_utxos);
    printf("txids[0]: %s\n", txids[0]);
    printf("vouts[0]: %d\n", vouts[0]);
    printf("txids[1]: %s\n", txids[1]);
    printf("vouts[1]: %d\n", vouts[1]);
    free_all_utxo_info(txids, vouts, num_utxos);
    return 0;
}

static char* test_get_utxo_balance() {
    const char* address = "1HqC6HfkvV8rXsAiKYaW6bFEoU4U8a17rH";
    const char* tx_id = "b7cfed48cbf56027899a4c1885ec14ea652b75aadeb400f82e30808c64af3581";
    uint64_t balance = get_utxo_balance(tx_id, address);
    printf("balance: %ld\n", balance);
    mu_assert("Error: get_utxo_balance doesn't work", balance == 8281);
    return 0;
}

static char* all_tests() {
    // mu_run_test(test_print_formatted_bytes);
    // mu_run_test(test_find_differences);

    #if S256Field_TEST
    mu_run_test(test_S256Field_eq);
    mu_run_test(test_S256Field_ne);
    mu_run_test(test_S256Field_add);
    mu_run_test(test_S256Field_sub);
    mu_run_test(test_S256Field_mul);
    mu_run_test(test_S256Field_s_mul);
    mu_run_test(test_S256Field_s_mul_scalar);
    mu_run_test(test_S256Field_mul_scalar);
    mu_run_test(test_S256Field_mod_inv);
    mu_run_test(test_S256Field_s_inv);
    mu_run_test(test_S256Field_pow);
    mu_run_test(test_S256Field_div);
    mu_run_test(test_S256Field_sqrt);
    #endif
    
    #if S256Point_TEST
    mu_run_test(test_S256Point_eq);
    mu_run_test(test_S256Point_ne);
    mu_run_test(test_S256Point_add);
    mu_run_test(test_S256Point_mul);
    mu_run_test(test_S256Point_verify);
    mu_run_test(test_S256Point_sec_uncompressed);
    mu_run_test(test_S256Point_sec_compressed);
    mu_run_test(test_S256Point_parse_sec);
    mu_run_test(test_S256Point_hash160);
    mu_run_test(test_S256Point_address);
    #endif

    #if PrivateKey_TEST
    mu_run_test(test_Deterministic_k);
    mu_run_test(test_PrivateKey_sign);
    mu_run_test(test_PrivateKey_wif);
    #endif

    #if Signature_TEST
    mu_run_test(test_Signature_der_length);
    mu_run_test(test_Signature_der);
    mu_run_test(test_Signature_parse);
    #endif

    #if Tx_TEST
    mu_run_test(test_Tx_id);
    mu_run_test(test_Tx_parse_version);
    mu_run_test(test_Tx_parse_inputs);
    mu_run_test(test_Tx_parse_outputs);
    mu_run_test(test_Tx_parse_locktime);
    mu_run_test(test_Tx_parse);
    mu_run_test(test_TxOut_serialize);
    mu_run_test(test_TxIn_serialize);
    mu_run_test(test_Tx_serialize);
    mu_run_test(test_fee);
    mu_run_test(test_http_get);
    mu_run_test(test_sig_hash);
    mu_run_test(test_verify_p2pkh);
    mu_run_test(test_verify_p2sh);
    mu_run_test(test_signing_transaction);
    mu_run_test(test_sign_input);
    //mu_run_test(test_create_real_transaciton);
    mu_run_test(test_create_testnet_transaction);
    #endif

    #if OP_TEST
    mu_run_test(test_encode_num);
    mu_run_test(test_decode_num);
    mu_run_test(test_Op_hash160);
    mu_run_test(test_Op_checksig);
    mu_run_test(test_Op_checkmultisig);
    #endif


    #if Script_TEST
    mu_run_test(test_Script_length);
    mu_run_test(test_p2pkh_script);
    mu_run_test(test_Script_parse);
    mu_run_test(test_Script_serialize);
    mu_run_test(test_Script_add);
    mu_run_test(test_Script_evaluate);
    mu_run_test(test_is_p2pkh_script_pubkey);
    mu_run_test(test_is_p2sh_script_pubkey);
    mu_run_test(test_is_p2wpkh_script_pubkey);
    mu_run_test(test_p2pk);
    mu_run_test(test_p2pkh);
    #endif

    #if Helper_TEST
    mu_run_test(test_sha1);
    mu_run_test(test_sha256);
    mu_run_test(test_ripemd160);
    mu_run_test(test_hash160);
    mu_run_test(test_hash256);
    mu_run_test(test_hash_to_mpz_t);
    mu_run_test(test_mpz_to_bytes);
    mu_run_test(test_mpz_to_32bytes);
    mu_run_test(test_compute_hmac_sha256);
    mu_run_test(test_encode_base58);
    mu_run_test(test_decode_base58);
    mu_run_test(test_encode_base58_checksum_address);
    mu_run_test(test_encode_base58_checksum_wif_uncompressed);
    mu_run_test(test_encode_base58_checksum_wif_compressed);
    mu_run_test(test_little_endian_to_int);
    mu_run_test(test_little_endian_to_long);
    mu_run_test(test_int_to_little_endian);
    mu_run_test(test_long_to_little_endian);
    mu_run_test(test_read_varint);
    mu_run_test(test_encode_varint);
    mu_run_test(test_little_endian_to_big_endian);
    mu_run_test(test_hex_string_to_byte_array);
    mu_run_test(test_byte_array_to_hex_string);
    mu_run_test(test_h160_to_p2pkh_address);
    mu_run_test(test_h160_to_p2sh_address);
    #endif

    #if Address_TEST
    mu_run_test(generate_testnet_address);
    #endif

    #if Other_TEST
    mu_run_test(test_verify_signature_from_transaction);
    #endif
    
    #if Wallet_TEST
    mu_run_test(test_get_balance);
    mu_run_test(test_extract_all_utxo_info);
    mu_run_test(test_get_utxo_balance);
    #endif

    return 0;
}

int main(int argc, char **argv) {
    Initialize_prime();

    char *result = all_tests();
    if (result != 0) {
        printf("%s\n", result);
    } else {
        printf("ALL TESTS PASSED\n");
    }
    printf("Tests run: %d\n", tests_run);

    Free_prime();

    return result != 0;
}