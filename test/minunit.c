#include <stdio.h>

#include "minunit.h"

#include "../bitcoin/ecc/s256field.h"
#include "../bitcoin/ecc/s256point.h"
#include "../bitcoin/ecc/signature.h"
#include "../bitcoin/ecc/privatekey.h"
#include "../bitcoin/tx/tx.h"
#include "../bitcoin/script/op.h"
#include "../bitcoin/script/script.h"

//For testing compressed sec and adding points with the same x
#define TEST_N "6d183de4400510e40d4f32da2e72168a5eaa3ee28bf6250923603284adfe55af"
#define TEST_O "434e7a05967edaf81ed577ad1956f5d517cf2370517e88c5c3da215c57bedc3f"
#define TEST_P "bcb185fa69812507e12a8852e6a90a2ae830dc8fae81773a3c25dea2a8411ff0"

//A and B can be a point and X and Y can be a point
#define TEST_A "887387e452b8eacc4acfde10d9aaf7f6d9a0f975aabb10d006e4da568744d06c"
#define TEST_B "61de6d95231cd89026e286df3b6ae4a894a3378e393e93a0f45b666329a0ae34"
#define TEST_X "deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef12345678"
#define TEST_Y "ffe4951c17e5edff2bb8f4a066b4bee9a962e60e709677d1cb376b38ea0d3bd8"

#define TEST_Z "ec208baa0fc1c19f708a9ca96fdeff3ac3f230bb4a7ba4aede4942ad003c0f60"
#define TEST_R "ac8d1c87e51d0d441be8b3dd5b05c8795b48875dffe00b7ffcfac23010d3a395"
#define TEST_S "68342ceff8935ededd102dd876ffd6ba72d6a427a3edb13d26eb0781cb423c4"
#define TEST_Z_2 "7c076ff316692a3d7eb3c3bb0f8b1488cf72e1afcd929e29307032997a838a3d"

//For testing signature DER format
#define TEST_DER_R "37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6"
#define TEST_DER_S "8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec"

int tests_run = 0;

static char* test_S256Field_add() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "de92540bf693acef0a66b39045627dd98810a4fe4f4436c1a9e52a28fc419621", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_add(test_x, test_y);
    mu_assert("Error: S256Field_add doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_sub() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "dec929d3c6c7d0f0b2f4ca4f77f90006354ad8e16e17471e137653b5282716cf", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_sub(test_x, test_y);
    mu_assert("Error: S256Field_sub doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mul() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "40ff672031c3ee56121ce660b15eb9111b5e97ca27c7beafb50ca874c9f38146", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_mul(test_x, test_y);
    mu_assert("Error: S256Field_mul doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_s_mul() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "d404f0aec405362faa5d716659f90317be0459052290161d04bbec2356c4c30f", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_s_mul(test_x, test_y);
    mu_assert("Error: S256Field_s_mul doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mul_scalar() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "40ff672031c3ee56121ce660b15eb9111b5e97ca27c7beafb50ca874c9f38146", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_mul_scalar(test_x, test_Y);
    mu_assert("Error: S256Field_mul_scalar doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(test_Y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_mod_inv() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "e14a08e686a1504acb1c1f23fa797e0b81476c6a157c6bfb19b55ac3e66e1d7c", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_mod_inv(test_x);
    mu_assert("Error: S256Field_mod_inv doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_s_inv() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "5d80dba49a677f43014d4250ba745be4eb6171982bd6205581fe48428ff08657", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_s_inv(test_x);
    mu_assert("Error: S256Field_s_inv doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_pow() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "4b4f242ad52794aa1a88e2dc56ec8032a91e0f857684e7d7d2c0edc2a38e7c87", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_pow(test_x, test_Y);
    mu_assert("Error: S256Field_pow doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(test_Y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_div() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "00dcad2ac055d0c9a239d0478b1227de5773683cbf67c6629cd7e6fb18ef5e21", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Field* result = S256Field_div(test_x, test_y);
    mu_assert("Error: S256Field_div doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    S256Field_free(test_y);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Field_sqrt() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t expected_result;
    mpz_init_set_str(expected_result, "3fca07c83ee3aef41802d1f79aed277c58d39d83d48e45d48320d10e3c1efd24", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* result = S256Field_sqrt(test_x);
    mu_assert("Error: S256Field_sqrt doesn't work", mpz_cmp(result->num, expected_result) == 0);
    S256Field_free(result);
    S256Field_free(test_x);
    mpz_clear(expected_result);
    return 0;
}

static char* test_S256Point_add() {
    //Adding two points with different x and y
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, 16);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, 16);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_x;
    mpz_init_set_str(expected_x, "456620086e0791dd93d1b8338cda34fde782c4c0290041099464de364ef3356a", 16);
    mpz_t expected_y;
    mpz_init_set_str(expected_y, "669b50ea184f441fc623362965e34074856e0cc909b74e291c61f7ddc1f683e2", 16);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* a = S256Point_init(test_a, test_b);
    S256Point* b = S256Point_init(test_x, test_y);
    S256Point* result = S256Point_add(a, b);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result->x->num, expected_x) == 0);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result->y->num, expected_y) == 0);
    S256Point_free(result);
    S256Point_free(a);
    S256Point_free(b);
    mpz_clear(expected_x);
    mpz_clear(expected_y);
    
    //Adding two points with the same x and different y
    mpz_t test_N1;
    mpz_init_set_str(test_N1, TEST_N, 16);
    mpz_t test_N2;
    mpz_init_set_str(test_N2, TEST_N, 16);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, 16);
    mpz_t test_P;
    mpz_init_set_str(test_P, TEST_P, 16);
    S256Field* test_n1 = S256Field_init(test_N1);
    S256Field* test_n2 = S256Field_init(test_N2);
    S256Field* test_o = S256Field_init(test_O);
    S256Field* test_p = S256Field_init(test_P);
    S256Point* c = S256Point_init(test_n1, test_o);
    S256Point* d = S256Point_init(test_n2, test_p);
    S256Point* result2 = S256Point_add(c, d);
    mu_assert("Error: S256Point_add doesn't work", result2 == NULL);
    S256Point_free(c);
    S256Point_free(d);

    //Adding two points with the same x and y
    mpz_t test_X1;
    mpz_init_set_str(test_X1, TEST_X, 16);
    mpz_t test_Y1;
    mpz_init_set_str(test_Y1, TEST_Y, 16);
    mpz_t test_X2;
    mpz_init_set_str(test_X2, TEST_X, 16);
    mpz_t test_Y2;
    mpz_init_set_str(test_Y2, TEST_Y, 16);
    mpz_t expected_x2;
    mpz_init_set_str(expected_x2, "4c528d70d1702dab37a7e442aa2331ac04884582de6f0fb23285d0ff8b1d9b8f", 16);
    mpz_t expected_y2;
    mpz_init_set_str(expected_y2, "e6f30b8af8fc994ed48f11ab8a560bb8d1fd7c4474e738c61a2fcc27398cbe25", 16);
    S256Field* test_x1 = S256Field_init(test_X1);
    S256Field* test_y1 = S256Field_init(test_Y1);
    S256Field* test_x2 = S256Field_init(test_X2);
    S256Field* test_y2 = S256Field_init(test_Y2);
    S256Point* e = S256Point_init(test_x1, test_y1);
    S256Point* f = S256Point_init(test_x2, test_y2);
    S256Point* result3 = S256Point_add(e, f);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result3->x->num, expected_x2) == 0);
    mu_assert("Error: S256Point_add doesn't work", mpz_cmp(result3->y->num, expected_y2) == 0);
    S256Point_free(result3);
    S256Point_free(e);
    S256Point_free(f);
    mpz_clear(expected_x2);
    mpz_clear(expected_y2);
    return 0;
}

static char* test_S256Point_mul() {
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, 16);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    mpz_t expected_x;
    mpz_init_set_str(expected_x, "d148d491f77e6546f6a2f371727a5dc6e8034fe116eecb405fc4b84feeaed996", 16);
    mpz_t expected_y;
    mpz_init_set_str(expected_y, "35c349a4272354858ef3be984c31e16d09282c872ba9189a93237f54c56dc5c8", 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* b = S256Point_init(test_x, test_y);
    S256Point* result = S256Point_mul(b, test_A);
    mu_assert("Error: S256Point_mul doesn't work", mpz_cmp(result->x->num, expected_x) == 0);
    mu_assert("Error: S256Point_mul doesn't work", mpz_cmp(result->y->num, expected_y) == 0);
    mpz_clear(test_A);
    mpz_clear(expected_x);
    mpz_clear(expected_y);
    S256Point_free(b);
    S256Point_free(result);
    return 0;
}

static char* test_S256Point_verify() {
    mpz_t test_A;
    mpz_init_set_str(test_A, TEST_A, 16);
    mpz_t test_B;
    mpz_init_set_str(test_B, TEST_B, 16);
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, 16);
    mpz_t test_R;
    mpz_init_set_str(test_R, TEST_R, 16);
    mpz_t test_S;
    mpz_init_set_str(test_S, TEST_S, 16);
    S256Field* test_z = S256Field_init(test_Z);
    S256Field* test_r = S256Field_init(test_R);
    S256Field* test_s = S256Field_init(test_S);
    S256Field* test_a = S256Field_init(test_A);
    S256Field* test_b = S256Field_init(test_B);
    Signature* test_sig = Signature_init(test_r, test_s);
    S256Point* test_p = S256Point_init(test_a, test_b);
    int result = S256Point_verify(test_p, test_z, test_sig);
    mu_assert("Error: S256Point_verify doesn't work", result == 1);
    S256Field_free(test_z);
    Signature_free(test_sig);
    S256Point_free(test_p);
    return 0;
}

static char* test_Deterministic_k() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, 16);
    S256Field* test_z = S256Field_init(test_Z);
    PrivateKey* test_key = PrivateKey_init("test secret");
    S256Field* test_k = Deterministic_k(test_key, test_z);
    mpz_t expected_k;
    mpz_init_set_str(expected_k, "76710a244f87c31c7e6024b6f7786908e49a82a658d3186ec3631a95350287e1", 16);
    mu_assert("Error: Deterministic_k doesn't work", mpz_cmp(test_k->num, expected_k) == 0);
    PrivateKey_free(test_key);
    S256Field_free(test_k);
    S256Field_free(test_z);
    mpz_clear(expected_k);
    return 0;
}

static char* test_PrivateKey_sign() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z, 16);
    S256Field* test_z = S256Field_init(test_Z);
    PrivateKey* test_key = PrivateKey_init("test secret");
    Signature* test_sig = PrivateKey_sign(test_key, test_z);
    mpz_t expected_r;
    mpz_init_set_str(expected_r, "efed461e09407dabdd08cedcbc31f1f421572a7a32077d16b448fb0bf1237028", 16);
    mpz_t expected_s;
    mpz_init_set_str(expected_s, "3fbf0cd46391e0a60c592f078354e9011b5218d5e741b04dfa6f688293ff3e95", 16);
    mu_assert("Error: PrivateKey_sign doesn't work", mpz_cmp(test_sig->r->num, expected_r) == 0);
    mu_assert("Error: PrivateKey_sign doesn't work", mpz_cmp(test_sig->s->num, expected_s) == 0);
    Signature_free(test_sig);
    PrivateKey_free(test_key);
    S256Field_free(test_z);
    mpz_clear(expected_r);
    mpz_clear(expected_s);
    return 0;
}

static char* test_S256Point_sec_uncompressed() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p = S256Point_init(test_x, test_y);
    unsigned char result[65];
    S256Point_sec_uncompressed(test_p, result);
    unsigned char expected_result[] = {0x04, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78, 0xff, 0xe4, 0x95, 0x1c, 0x17, 0xe5, 0xed, 0xff, 0x2b, 0xb8, 0xf4, 0xa0, 0x66, 0xb4, 0xbe, 0xe9, 0xa9, 0x62, 0xe6, 0x0e, 0x70, 0x96, 0x77, 0xd1, 0xcb, 0x37, 0x6b, 0x38, 0xea, 0x0d, 0x3b, 0xd8};
    mu_assert("Error: S256Point_sec_uncompressed doesn't work", memcmp(result, expected_result, sizeof(expected_result)) == 0);
    S256Point_free(test_p);
    return 0;
}

static char* test_S256Point_sec_compressed() {
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p_even = S256Point_init(test_x, test_y);
    unsigned char result_even[33];
    S256Point_sec_compressed(test_p_even, result_even);
    mpz_t test_N;
    mpz_init_set_str(test_N, TEST_N, 16);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, 16);
    S256Field* test_n = S256Field_init(test_N);
    S256Field* test_o = S256Field_init(test_O);
    S256Point* test_p_odd = S256Point_init(test_n, test_o);
    unsigned char result_odd[33];
    S256Point_sec_compressed(test_p_odd, result_odd);
    unsigned char expected_result_even[] = {0x02, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78};
    unsigned char expected_result_odd[] = {0x03, 0x6d, 0x18, 0x3d, 0xe4, 0x40, 0x05, 0x10, 0xe4, 0x0d, 0x4f, 0x32, 0xda, 0x2e, 0x72, 0x16, 0x8a, 0x5e, 0xaa, 0x3e, 0xe2, 0x8b, 0xf6, 0x25, 0x09, 0x23, 0x60, 0x32, 0x84, 0xad, 0xfe, 0x55, 0xaf};
    mu_assert("Error: S256Point_sec_compressed doesn't work", memcmp(result_even, expected_result_even, sizeof(expected_result_even)) == 0);
    mu_assert("Error: S256Point_sec_compressed doesn't work", memcmp(result_odd, expected_result_odd, sizeof(expected_result_odd)) == 0);
    S256Point_free(test_p_even);
    S256Point_free(test_p_odd);
    return 0;
}

static char* test_S256Point_parse_sec() {
    unsigned char test_compressed_sec_even[] = {0x02, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78};
    S256Point* test_compressed_even_result = S256Point_parse_sec(test_compressed_sec_even);
    unsigned char test_compressed_sec_odd[] = {0x03, 0x6d, 0x18, 0x3d, 0xe4, 0x40, 0x05, 0x10, 0xe4, 0x0d, 0x4f, 0x32, 0xda, 0x2e, 0x72, 0x16, 0x8a, 0x5e, 0xaa, 0x3e, 0xe2, 0x8b, 0xf6, 0x25, 0x09, 0x23, 0x60, 0x32, 0x84, 0xad, 0xfe, 0x55, 0xaf};
    S256Point* test_compressed_odd_result = S256Point_parse_sec(test_compressed_sec_odd);
    unsigned char test_uncompressed_sec[] = {0x04, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef, 0x12, 0x34, 0x56, 0x78, 0xff, 0xe4, 0x95, 0x1c, 0x17, 0xe5, 0xed, 0xff, 0x2b, 0xb8, 0xf4, 0xa0, 0x66, 0xb4, 0xbe, 0xe9, 0xa9, 0x62, 0xe6, 0x0e, 0x70, 0x96, 0x77, 0xd1, 0xcb, 0x37, 0x6b, 0x38, 0xea, 0x0d, 0x3b, 0xd8};
    S256Point* test_uncompressed_result = S256Point_parse_sec(test_uncompressed_sec);
    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* expected_result = S256Point_init(test_x, test_y);
    mpz_t test_N;
    mpz_init_set_str(test_N, TEST_N, 16);
    mpz_t test_O;
    mpz_init_set_str(test_O, TEST_O, 16);
    S256Field* test_n = S256Field_init(test_N);
    S256Field* test_o = S256Field_init(test_O);
    S256Point* expected_odd_result = S256Point_init(test_n, test_o);
    mu_assert("Error: S256Point_parse_sec doesn't work", S256Point_eq(test_uncompressed_result, expected_result) && S256Point_eq(test_compressed_even_result, expected_result) && S256Point_eq(test_compressed_odd_result, expected_odd_result));
    S256Point_free(test_compressed_even_result);
    S256Point_free(test_compressed_odd_result);
    S256Point_free(test_uncompressed_result);
    S256Point_free(expected_result);
    S256Point_free(expected_odd_result);
    return 0;
}

static char* test_Signature_der() {
    mpz_t test_R1;
    mpz_init_set_str(test_R1, TEST_DER_R, 16);
    mpz_t test_S1;
    mpz_init_set_str(test_S1, TEST_DER_S, 16);
    mpz_t test_R2;
    mpz_init_set_str(test_R2, TEST_R, 16);
    mpz_t test_S2;
    mpz_init_set_str(test_S2, TEST_S, 16);
    S256Field* test_r1 = S256Field_init(test_R1);
    S256Field* test_s1 = S256Field_init(test_S1);
    Signature* test_sig1 = Signature_init(test_r1, test_s1);
    S256Field* test_r2 = S256Field_init(test_R2);
    S256Field* test_s2 = S256Field_init(test_S2);
    Signature* test_sig2 = Signature_init(test_r2, test_s2);
    unsigned char result1[72] = {0};
    unsigned char result2[72] = {0};
    Signature_der(test_sig1, result1);
    Signature_der(test_sig2, result2);
    unsigned char expected_result1[72] = {0x30, 0x45, 0x02, 0x20, 0x37, 0x20, 0x6a, 0x06, 0x10, 0x99, 0x5c, 0x58, 0x07, 0x49, 0x99, 0xcb, 0x97, 0x67, 0xb8, 0x7a, 0xf4, 0xc4, 0x97, 0x8d, 0xb6, 0x8c, 0x06, 0xe8, 0xe6, 0xe8, 0x1d, 0x28, 0x20, 0x47, 0xa7, 0xc6, 0x02, 0x21, 0x00, 0x8c, 0xa6, 0x37, 0x59, 0xc1, 0x15, 0x7e, 0xbe, 0xae, 0xc0, 0xd0, 0x3c, 0xec, 0xca, 0x11, 0x9f, 0xc9, 0xa7, 0x5b, 0xf8, 0xe6, 0xd0, 0xfa, 0x65, 0xc8, 0x41, 0xc8, 0xe2, 0x73, 0x8c, 0xda, 0xec};
    unsigned char expected_result2[72] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xac, 0x8d, 0x1c, 0x87, 0xe5, 0x1d, 0x0d, 0x44, 0x1b, 0xe8, 0xb3, 0xdd, 0x5b, 0x05, 0xc8, 0x79, 0x5b, 0x48, 0x87, 0x5d, 0xff, 0xe0, 0x0b, 0x7f, 0xfc, 0xfa, 0xc2, 0x30, 0x10, 0xd3, 0xa3, 0x95, 0x02, 0x20, 0x06, 0x83, 0x42, 0xce, 0xff, 0x89, 0x35, 0xed, 0xed, 0xd1, 0x02, 0xdd, 0x87, 0x6f, 0xfd, 0x6b, 0xa7, 0x2d, 0x6a, 0x42, 0x7a, 0x3e, 0xdb, 0x13, 0xd2, 0x6e, 0xb0, 0x78, 0x1c, 0xb4, 0x23, 0xc4};
    mu_assert("Error: Signature_der doesn't work (result 1)", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    mu_assert("Error: Signature_der doesn't work (result 2)", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    Signature_free(test_sig1);
    Signature_free(test_sig2);
    return 0;
}

static char* test_Signature_parse() {
    mpz_t test_R1;
    mpz_init_set_str(test_R1, TEST_DER_R, 16);
    mpz_t test_S1;
    mpz_init_set_str(test_S1, TEST_DER_S, 16);
    mpz_t test_R2;
    mpz_init_set_str(test_R2, TEST_R, 16);
    mpz_t test_S2;
    mpz_init_set_str(test_S2, TEST_S, 16);
    unsigned char raw_sig_1[] = {0x30, 0x45, 0x02, 0x20, 0x37, 0x20, 0x6a, 0x06, 0x10, 0x99, 0x5c, 0x58, 0x07, 0x49, 0x99, 0xcb, 0x97, 0x67, 0xb8, 0x7a, 0xf4, 0xc4, 0x97, 0x8d, 0xb6, 0x8c, 0x06, 0xe8, 0xe6, 0xe8, 0x1d, 0x28, 0x20, 0x47, 0xa7, 0xc6, 0x02, 0x21, 0x00, 0x8c, 0xa6, 0x37, 0x59, 0xc1, 0x15, 0x7e, 0xbe, 0xae, 0xc0, 0xd0, 0x3c, 0xec, 0xca, 0x11, 0x9f, 0xc9, 0xa7, 0x5b, 0xf8, 0xe6, 0xd0, 0xfa, 0x65, 0xc8, 0x41, 0xc8, 0xe2, 0x73, 0x8c, 0xda, 0xec};
    unsigned char raw_sig_2[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xac, 0x8d, 0x1c, 0x87, 0xe5, 0x1d, 0x0d, 0x44, 0x1b, 0xe8, 0xb3, 0xdd, 0x5b, 0x05, 0xc8, 0x79, 0x5b, 0x48, 0x87, 0x5d, 0xff, 0xe0, 0x0b, 0x7f, 0xfc, 0xfa, 0xc2, 0x30, 0x10, 0xd3, 0xa3, 0x95, 0x02, 0x20, 0x06, 0x83, 0x42, 0xce, 0xff, 0x89, 0x35, 0xed, 0xed, 0xd1, 0x02, 0xdd, 0x87, 0x6f, 0xfd, 0x6b, 0xa7, 0x2d, 0x6a, 0x42, 0x7a, 0x3e, 0xdb, 0x13, 0xd2, 0x6e, 0xb0, 0x78, 0x1c, 0xb4, 0x23, 0xc4};
    Signature* sig_1 = Signature_parse(raw_sig_1);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_1->r->num, test_R1) == 0);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_1->s->num, test_S1) == 0);
    Signature* sig_2 = Signature_parse(raw_sig_2);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_2->r->num, test_R2) == 0);
    mu_assert("Error: Signature_parse doesn't work", mpz_cmp(sig_2->s->num, test_S2) == 0);
    Signature_free(sig_1);
    Signature_free(sig_2);
    mpz_clear(test_R1);
    mpz_clear(test_S1);
    mpz_clear(test_R2);
    mpz_clear(test_S2);
    return 0;
}

static char* test_encode_base58() {
    const char test1[] = {0x7c, 0x07, 0x6f, 0xf3, 0x16, 0x69, 0x2a, 0x3d, 0x7e, 0xb3, 0xc3, 0xbb, 0x0f, 0x8b, 0x14, 0x88, 0xcf, 0x72, 0xe1, 0xaf, 0xcd, 0x92, 0x9e, 0x29, 0x30, 0x70, 0x32, 0x99, 0x7a, 0x83, 0x8a, 0x3d};
    unsigned char result1[1024];
    size_t size = 1024;
    encode_base58(result1, &size, test1, sizeof(test1));
    char* expected_result1 = "9MA8fRQrT4u8Zj8ZRd6MAiiyaxb2Y1CMpvVkHQu5hVM6";
    mu_assert("Error: encode_base58 doesn't work (result 1)", strcmp((char*)result1, expected_result1) == 0);
    const char test2[] = {0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c};
    unsigned char result2[1024];
    encode_base58(result2, &size, test2, sizeof(test2));
    char* expected_result2 = "4fE3H2E6XMp4SsxtwinF7w9a34ooUrwWe4WsW1458Pd";
    mu_assert("Error: encode_base58 doesn't work (result 2)", strcmp((char*)result2, expected_result2) == 0);
    const char test3[] = {0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6};
    unsigned char result3[1024];
    encode_base58(result3, &size, test3, sizeof(test3));
    char* expected_result3 = "EQJsjkd6JaGwxrjEhfeqPenqHwrBmPQZjJGNSCHBkcF7";
    mu_assert("Error: encode_base58 doesn't work (result 3)", strcmp((char*)result3, expected_result3) == 0);
    return 0;
}

static char* test_S256Point_address() {
    // PrivateKey* test_key = PrivateKey_init("test secret");
    // char result[1024];
    // S256Point_address(test_key->point, result, FALSE, TRUE);
    // char* expected_result = "oDXeZKUNbGkmjpw9adB79LHZ3w2kGdDtkkmLwjEA36cPD";
    // mu_assert("Error: S256Point_address doesn't work", strcmp(result, expected_result) == 0);
    // PrivateKey_free(test_key);

    mpz_t test_X;
    mpz_init_set_str(test_X, TEST_X, 16);
    mpz_t test_Y;
    mpz_init_set_str(test_Y, TEST_Y, 16);
    S256Field* test_x = S256Field_init(test_X);
    S256Field* test_y = S256Field_init(test_Y);
    S256Point* test_p = S256Point_init(test_x, test_y);
    
    unsigned char result1[1024];
    S256Point_address(test_p, result1, FALSE, FALSE);
    char* expected_result1 = "1JjuTbJNnZ7oxmvsMKkwhQcwKZBNB57Dc2";

    unsigned char result2[1024];
    S256Point_address(test_p, result2, TRUE, FALSE);
    char* expected_result2 = "1EmNjxzL2pEeAdkFzJNmU2wzQQHrNFtA9J";

    unsigned char result3[1024];
    S256Point_address(test_p, result3, FALSE, TRUE);
    char* expected_result3 = "myFrkePMbaZ4jtQV4tjKXKqGBYn56ioF2S";

    unsigned char result4[1024];
    S256Point_address(test_p, result4, TRUE, TRUE);
    char* expected_result4 = "muHL325JqqftwkDshsM9HxAKGPtZNLmusA";

    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result1, expected_result1) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result2, expected_result2) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result3, expected_result3) == 0);
    mu_assert("Error: S256Point_address doesn't work", strcmp((char*)result4, expected_result4) == 0);

    S256Point_free(test_p);
    return 0;
}

static char* test_PrivateKey_wif() {
    PrivateKey* test_key = PrivateKey_init("test secret");

    unsigned char result1[1024];
    PrivateKey_wif(test_key, result1, FALSE, FALSE);
    char* expected_result1 = "5K4T5kjMFenTMzWNNwAjBcBrBVwhLqWuWm2MPBfAnb9LnexWEmJ";

    unsigned char result2[1024];
    PrivateKey_wif(test_key, result2, TRUE, FALSE);
    char* expected_result2 = "L2iE7z1vPfmdMepdMp5wBpJt5LkR4Z8znMJxxv3UCDhpL6DGw9pC";

    unsigned char result3[1024];
    PrivateKey_wif(test_key, result3, FALSE, TRUE);
    char* expected_result3 = "92q5fVYtqsrbL41f1H4e4CjoqAJQW146rhtJTp1g8KtPZgBaKKL";

    unsigned char result4[1024];
    PrivateKey_wif(test_key, result4, TRUE, TRUE);
    char* expected_result4 = "cT5Dau1mpjTtX6HtkDu4Z8owha3pj1EgrPTS5LVyhLMpaqPXeAbg";

    mu_assert("Error: PrivateKey_wif doesn't work", strcmp((char*)result1, expected_result1) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work", strcmp((char*)result2, expected_result2) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work", strcmp((char*)result3, expected_result3) == 0);
    mu_assert("Error: PrivateKey_wif doesn't work", strcmp((char*)result4, expected_result4) == 0);

    PrivateKey_free(test_key);
    return 0;
}

static char* generate_testnet_address() {
    PrivateKey* test_key = PrivateKey_init("test secret");
    unsigned char testnet_address[1024];
    S256Point_address(test_key->point, testnet_address, FALSE, TRUE);
    printf("Testnet address: %s\n", testnet_address);
    PrivateKey_free(test_key);
    return 0;
}

static char* test_little_endian_to_int() {
    unsigned char test1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test1, 4) == 1);
    unsigned char test2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test2, 4) == 16843009);
    unsigned char test3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_int doesn't work", little_endian_to_int(test3, 3) == 16777215);
    return 0;
}

static char* test_int_to_little_endian() {
    unsigned char result1[4];
    int_to_little_endian(1, result1, 4);
    unsigned char expected_result1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    unsigned char result2[4];
    int_to_little_endian(16843009, result2, 4);
    unsigned char expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    unsigned char result3[3];
    int_to_little_endian(16777215, result3, 3);
    unsigned char expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: int_to_little_endian doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    return 0;
}

static char* test_little_endian_to_long() {
    unsigned char test1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test1, 4) == 1);
    unsigned char test2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test2, 4) == 16843009);
    unsigned char test3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test3, 3) == 16777215);
    unsigned char test4[] = {0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: little_endian_to_long doesn't work", little_endian_to_long(test4, 8) == 18005558675309);
    return 0;
}

static char* test_long_to_little_endian() {
    unsigned char result1[4];
    long_to_little_endian(1, result1, 4);
    unsigned char expected_result1[] = {0x01, 0x00, 0x00, 0x00};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    unsigned char result2[4];
    long_to_little_endian(16843009, result2, 4);
    unsigned char expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    unsigned char result3[3];
    long_to_little_endian(16777215, result3, 3);
    unsigned char expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    unsigned char result4[8];
    long_to_little_endian(18005558675309, result4, 8);
    unsigned char expected_result4[] = {0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: long_to_little_endian doesn't work", memcmp(result4, expected_result4, sizeof(expected_result4)) == 0);
    return 0;
}

static char* test_Tx_parse_version() {
    unsigned char raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, FALSE);
    mu_assert("Error: Tx_parse doesn't work for version", test_tx->version == 1);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse_inputs() {
    unsigned char raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, FALSE);
    mu_assert("Error: Tx_parse doesn't work for num_inputs", test_tx->num_inputs == 1);
    unsigned char want1[32] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81};
    mu_assert("Error: Tx_parse doesn't work for prev_tx", memcmp(test_tx->tx_ins[0]->prev_tx, want1, 32) == 0);
    mu_assert("Error: Tx_parse doesn't work for prev_index", test_tx->tx_ins[0]->prev_index == 0);
    unsigned char want2[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    unsigned char scriptsig_serialized[108];
    script_serialize(test_tx->tx_ins[0]->script_sig, scriptsig_serialized);
    mu_assert("Error: Tx_parse doesn't work for script_sig", memcmp(scriptsig_serialized, want2, 108) == 0);
    mu_assert("Error: Tx_parse doesn't work for sequence", test_tx->tx_ins[0]->sequence == 0xfffffffe);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse_outputs() {
    unsigned char raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, FALSE);
    mu_assert("Error: Tx_parse doesn't work for num_outputs", test_tx->num_outputs == 2);
    unsigned long long want1 = 32454049;
    mu_assert("Error: Tx_parse doesn't work for amount", test_tx->tx_outs[0]->amount == want1);
    unsigned char want2[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    unsigned char scriptpubkey_serialized_1[26];
    script_serialize(test_tx->tx_outs[0]->script_pubkey, scriptpubkey_serialized_1);
    mu_assert("Error: Tx_parse doesn't work for script_pubkey", memcmp(scriptpubkey_serialized_1, want2, 26) == 0);
    unsigned long long want3 = 10011545;
    mu_assert("Error: Tx_parse doesn't work for amount", test_tx->tx_outs[1]->amount == want3);
    unsigned char want4[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    unsigned char scriptpubkey_serialized_2[26];
    script_serialize(test_tx->tx_outs[1]->script_pubkey, scriptpubkey_serialized_2);
    mu_assert("Error: Tx_parse doesn't work for script_pubkey", memcmp(scriptpubkey_serialized_2, want4, 26) == 0);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse_locktime() {
    unsigned char raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, FALSE);
    mu_assert("Error: Tx_parse doesn't work for locktime", test_tx->locktime == 410393);
    Tx_free(test_tx);
    return 0;
}

static char* test_Tx_parse() {
    unsigned char raw_tx[] = {0x01, 0x00, 0x00, 0x00, 0x04, 0x56, 0x91, 0x99, 0x60, 0xac, 0x69, 0x17, 0x63, 0x68, 0x8d, 0x3d, 0x3b, 0xce, 0xa9, 0xad, 0x6e, 0xca, 0xf8, 0x75, 0xdf, 0x53, 0x39, 0xe1, 0x48, 0xa1, 0xfc, 0x61, 0xc6, 0xed, 0x7a, 0x06, 0x9e, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x45, 0x85, 0xbc, 0xde, 0xf8, 0x5e, 0x6b, 0x1c, 0x6a, 0xf5, 0xc2, 0x66, 0x9d, 0x48, 0x30, 0xff, 0x86, 0xe4, 0x2d, 0xd2, 0x05, 0xc0, 0xe0, 0x89, 0xbc, 0x2a, 0x82, 0x16, 0x57, 0xe9, 0x51, 0xc0, 0x02, 0x20, 0x10, 0x24, 0xa1, 0x03, 0x66, 0x07, 0x7f, 0x87, 0xd6, 0xbc, 0xe1, 0xf7, 0x10, 0x0a, 0xd8, 0xcf, 0xa8, 0xa0, 0x64, 0xb3, 0x9d, 0x4e, 0x8f, 0xe4, 0xea, 0x13, 0xa7, 0xb7, 0x1a, 0xa8, 0x18, 0x0f, 0x01, 0x21, 0x02, 0xf0, 0xda, 0x57, 0xe8, 0x5e, 0xec, 0x29, 0x34, 0xa8, 0x2a, 0x58, 0x5e, 0xa3, 0x37, 0xce, 0x2f, 0x49, 0x98, 0xb5, 0x0a, 0xe6, 0x99, 0xdd, 0x79, 0xf5, 0x88, 0x0e, 0x25, 0x3d, 0xaf, 0xaf, 0xb7, 0xfe, 0xff, 0xff, 0xff, 0xeb, 0x8f, 0x51, 0xf4, 0x03, 0x8d, 0xc1, 0x7e, 0x63, 0x13, 0xcf, 0x83, 0x1d, 0x4f, 0x02, 0x28, 0x1c, 0x2a, 0x46, 0x8b, 0xde, 0x0f, 0xaf, 0xd3, 0x7f, 0x1b, 0xf8, 0x82, 0x72, 0x9e, 0x7f, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37, 0xfe, 0xff, 0xff, 0xff, 0x56, 0x7b, 0xf4, 0x05, 0x95, 0x11, 0x9d, 0x1b, 0xb8, 0xa3, 0x03, 0x7c, 0x35, 0x6e, 0xfd, 0x56, 0x17, 0x0b, 0x64, 0xcb, 0xcc, 0x16, 0x0f, 0xb0, 0x28, 0xfa, 0x10, 0x70, 0x4b, 0x45, 0xd7, 0x75, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x4c, 0x7c, 0x78, 0x18, 0x42, 0x4c, 0x7f, 0x79, 0x11, 0xda, 0x6c, 0xdd, 0xc5, 0x96, 0x55, 0xa7, 0x0a, 0xf1, 0xcb, 0x5e, 0xaf, 0x17, 0xc6, 0x9d, 0xad, 0xbf, 0xc7, 0x4f, 0xfa, 0x0b, 0x66, 0x2f, 0x02, 0x20, 0x75, 0x99, 0xe0, 0x8b, 0xc8, 0x02, 0x36, 0x93, 0xad, 0x4e, 0x95, 0x27, 0xdc, 0x42, 0xc3, 0x42, 0x10, 0xf7, 0xa7, 0xd1, 0xd1, 0xdd, 0xfc, 0x84, 0x92, 0xb6, 0x54, 0xa1, 0x1e, 0x76, 0x20, 0xa0, 0x01, 0x21, 0x02, 0x15, 0x8b, 0x46, 0xfb, 0xdf, 0xf6, 0x5d, 0x01, 0x72, 0xb7, 0x98, 0x9a, 0xec, 0x88, 0x50, 0xaa, 0x0d, 0xae, 0x49, 0xab, 0xfb, 0x84, 0xc8, 0x1a, 0xe6, 0xe5, 0xb2, 0x51, 0xa5, 0x8a, 0xce, 0x5c, 0xfe, 0xff, 0xff, 0xff, 0xd6, 0x3a, 0x5e, 0x6c, 0x16, 0xe6, 0x20, 0xf8, 0x6f, 0x37, 0x59, 0x25, 0xb2, 0x1c, 0xab, 0xaf, 0x73, 0x6c, 0x77, 0x9f, 0x88, 0xfd, 0x04, 0xdc, 0xad, 0x51, 0xd2, 0x66, 0x90, 0xf7, 0xf3, 0x45, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x06, 0x33, 0xea, 0x0d, 0x33, 0x14, 0xbe, 0xa0, 0xd9, 0x5b, 0x3c, 0xd8, 0xda, 0xdb, 0x2e, 0xf7, 0x9e, 0xa8, 0x33, 0x1f, 0xfe, 0x1e, 0x61, 0xf7, 0x62, 0xc0, 0xf6, 0xda, 0xea, 0x0f, 0xab, 0xde, 0x02, 0x20, 0x29, 0xf2, 0x3b, 0x3e, 0x9c, 0x30, 0xf0, 0x80, 0x44, 0x61, 0x50, 0xb2, 0x38, 0x52, 0x02, 0x87, 0x51, 0x63, 0x5d, 0xce, 0xe2, 0xbe, 0x66, 0x9c, 0x2a, 0x16, 0x86, 0xa4, 0xb5, 0xed, 0xf3, 0x04, 0x01, 0x21, 0x03, 0xff, 0xd6, 0xf4, 0xa6, 0x7e, 0x94, 0xab, 0xa3, 0x53, 0xa0, 0x08, 0x82, 0xe5, 0x63, 0xff, 0x27, 0x22, 0xeb, 0x4c, 0xff, 0x0a, 0xd6, 0x00, 0x6e, 0x86, 0xee, 0x20, 0xdf, 0xe7, 0x52, 0x0d, 0x55, 0xfe, 0xff, 0xff, 0xff, 0x02, 0x51, 0x43, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xab, 0x0c, 0x0b, 0x2e, 0x98, 0xb1, 0xab, 0x6d, 0xbf, 0x67, 0xd4, 0x75, 0x0b, 0x0a, 0x56, 0x24, 0x49, 0x48, 0xa8, 0x79, 0x88, 0xac, 0x00, 0x5a, 0x62, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x3c, 0x82, 0xd7, 0xdf, 0x36, 0x4e, 0xb6, 0xc7, 0x5b, 0xe8, 0xc8, 0x0d, 0xf2, 0xb3, 0xed, 0xa8, 0xdb, 0x57, 0x39, 0x70, 0x88, 0xac, 0x46, 0x43, 0x06, 0x00};
    Tx* test_tx = Tx_parse(raw_tx, FALSE);
    mu_assert("Error: Tx_parse doesn't work for version", test_tx->version == 1);
    mu_assert("Error: Tx_parse doesn't work for num_inputs", test_tx->num_inputs == 4);
    mu_assert("Error: Tx_parse doesn't work for num_outputs", test_tx->num_outputs == 2);
    mu_assert("Error: Tx_parse doesn't work for locktime", test_tx->locktime == 410438);
    Tx_free(test_tx);
    return 0;
}

static char* test_print_formatted_bytes() {
    const unsigned char* hex_string = (const unsigned char*)"9e067aedc661fca148e13953df75f8ca6eada9ce3b3d8d68631769ac60999156";
    print_formatted_bytes(hex_string);
    const unsigned char* hex_string_2 = (const unsigned char*)"25";
    print_formatted_bytes(hex_string_2);
    return 0;
}

static char* test_read_varint() {
    unsigned char data1[] = {0x64};
    unsigned long long num1 = read_varint(data1);
    mu_assert("Error: read_varint doesn't work", num1 == 100);
    unsigned char data2[] = {0xfd, 0xff, 0x00};
    unsigned long long num2 = read_varint(data2);
    mu_assert("Error: read_varint doesn't work", num2 == 255);
    unsigned char data3[] = {0xfd, 0x2b, 0x02};
    unsigned long long num3 = read_varint(data3);
    mu_assert("Error: read_varint doesn't work", num3 == 555);
    unsigned char data4[] = {0xfe, 0x7f, 0x11, 0x01, 0x00};
    unsigned long long num4 = read_varint(data4);
    mu_assert("Error: read_varint doesn't work", num4 == 70015);
    unsigned char data5[] = {0xff, 0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    unsigned long long num5 = read_varint(data5);
    mu_assert("Error: read_varint doesn't work", num5 == 18005558675309);
    return 0;
}

static char* test_encode_varint() {
    unsigned long long num1 = 100;
    unsigned char result1[1024];
    encode_varint(result1, num1);
    unsigned char expected_result1[] = {0x64};
    mu_assert("Error: encode_varint doesn't work", memcmp(result1, expected_result1, sizeof(expected_result1)) == 0);
    unsigned long long num2 = 255;
    unsigned char result2[1024];
    encode_varint(result2, num2);
    unsigned char expected_result2[] = {0xfd, 0xff, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result2, expected_result2, sizeof(expected_result2)) == 0);
    unsigned long long num3 = 555;
    unsigned char result3[1024];
    encode_varint(result3, num3);
    unsigned char expected_result3[] = {0xfd, 0x2b, 0x02};
    mu_assert("Error: encode_varint doesn't work", memcmp(result3, expected_result3, sizeof(expected_result3)) == 0);
    unsigned long long num4 = 70015;
    unsigned char result4[1024];
    encode_varint(result4, num4);
    unsigned char expected_result4[] = {0xfe, 0x7f, 0x11, 0x01, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result4, expected_result4, sizeof(expected_result4)) == 0);
    unsigned long long num5 = 18005558675309;
    unsigned char result5[1024];
    encode_varint(result5, num5);
    unsigned char expected_result5[] = {0xff, 0x6d, 0xc7, 0xed, 0x3e, 0x60, 0x10, 0x00, 0x00};
    mu_assert("Error: encode_varint doesn't work", memcmp(result5, expected_result5, sizeof(expected_result5)) == 0);
    return 0;
}

static char* test_little_endian_to_big_endian() {
    unsigned char test1[] = {0x01, 0x00, 0x00, 0x00};
    little_endian_to_big_endian(test1, 4);
    unsigned char expected_result1[] = {0x00, 0x00, 0x00, 0x01};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test1, expected_result1, sizeof(expected_result1)) == 0);
    unsigned char test2[] = {0x01, 0x01, 0x01, 0x01};
    little_endian_to_big_endian(test2, 4);
    unsigned char expected_result2[] = {0x01, 0x01, 0x01, 0x01};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test2, expected_result2, sizeof(expected_result2)) == 0);
    unsigned char test3[] = {0xff, 0xff, 0xff};
    little_endian_to_big_endian(test3, 3);
    unsigned char expected_result3[] = {0xff, 0xff, 0xff};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test3, expected_result3, sizeof(expected_result3)) == 0);
    unsigned char test4[] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    little_endian_to_big_endian(test4, 32);
    unsigned char expected_result4[] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81};
    mu_assert("Error: little_endian_to_big_endian doesn't work", memcmp(test4, expected_result4, sizeof(expected_result4)) == 0);
    return 0;
}

static char* test_TxOut_serialize() {
    unsigned char script_pubkey_1_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    Script* script_pubkey_1 = script_init();
    Command cmd_1;
    memcpy(cmd_1.data, script_pubkey_1_raw + 1, 24);
    cmd_1.data_len = 24;
    Command cmd_2;
    cmd_2.data[0] = 0xac;
    cmd_2.data_len = 1;
    script_pubkey_1->cmds[0] = cmd_1;
    script_pubkey_1->cmds[1] = cmd_2;
    script_pubkey_1->cmds_len = 2;
    TxOut* tx_out_1 = TxOut_init(32454049, script_pubkey_1);
    unsigned char result_1[35];
    TxOut_serialize(tx_out_1, result_1);
    unsigned char expected_result_1[35] = {0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x18, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_1, expected_result_1, 35) == 0);
    TxOut_free(tx_out_1);

    Script* script_pubkey_3 = script_parse(script_pubkey_1_raw);
    TxOut* tx_out_3 = TxOut_init(32454049, script_pubkey_3);
    unsigned char result_3[34];
    TxOut_serialize(tx_out_3, result_3);
    unsigned char expected_result_3[34] = {0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_3, expected_result_3, 34) == 0);
    TxOut_free(tx_out_3);

    unsigned char script_pubkey_2_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    Script* script_pubkey_2 = script_init();
    Command cmd_3;
    memcpy(cmd_3.data, script_pubkey_2_raw + 1, 24);
    cmd_3.data_len = 24;
    Command cmd_4;
    cmd_4.data[0] = 0xac;
    cmd_4.data_len = 1;
    script_pubkey_2->cmds[0] = cmd_3;
    script_pubkey_2->cmds[1] = cmd_4;
    script_pubkey_2->cmds_len = 2;
    TxOut* tx_out_2 = TxOut_init(10011545, script_pubkey_2);
    unsigned char result_2[35];
    TxOut_serialize(tx_out_2, result_2);
    unsigned char expected_result_2[] = {0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x18, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    mu_assert("Error: TxOut_serialize doesn't work", memcmp(result_2, expected_result_2, 35) == 0);
    TxOut_free(tx_out_2);
    return 0;
}

static char* test_TxIn_serialize() {
    unsigned char prev_tx[32] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    int prev_index = 0;
    unsigned char script_sig_raw[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_sig = script_parse(script_sig_raw);
    int sequence = 0xfffffffe;
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, sequence);
    unsigned char result[148];
    TxIn_serialize(tx_in, result);
    unsigned char expected_result[] = {0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff};
    mu_assert("Error: TxIn_serialize doesn't work", memcmp(result, expected_result, 148) == 0);
    TxIn_free(tx_in);
    return 0;
}

static char* test_Tx_serialize() {
    int version = 1;
    unsigned long long num_inputs = 1;
    unsigned long long num_outputs = 2;
    unsigned long long locktime = 410393;
    TxIn** tx_ins = (TxIn**)malloc(num_inputs * sizeof(TxIn*));
    unsigned char prev_tx[32] = {0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1};
    int prev_index = 0;
    unsigned char script_sig_raw[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_sig = script_parse(script_sig_raw);
    int sequence = 0xfffffffe;
    TxIn* tx_in = TxIn_init(prev_tx, prev_index, script_sig, sequence);
    tx_ins[0] = tx_in;
    TxOut** tx_outs = (TxOut**)malloc(num_outputs * sizeof(TxOut*));
    unsigned char script_pubkey_1_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac};
    Script* script_pubkey_1 = script_parse(script_pubkey_1_raw);
    TxOut* tx_out_1 = TxOut_init(32454049, script_pubkey_1);
    tx_outs[0] = tx_out_1;
    unsigned char script_pubkey_2_raw[26] = {0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac};
    Script* script_pubkey_2 = script_parse(script_pubkey_2_raw);
    TxOut* tx_out_2 = TxOut_init(10011545, script_pubkey_2);
    tx_outs[1] = tx_out_2;
    Tx* tx = Tx_init(version, num_inputs, tx_ins, num_outputs, tx_outs, locktime, FALSE);
    unsigned char result[226];
    Tx_serialize(tx, result);
    unsigned char expected_result[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    mu_assert("Error: Tx_serialize doesn't work", memcmp(result, expected_result, 226) == 0);
    Tx_free(tx);
    return 0;
}

static char* test_http_get() {
    // const char* url = "http://httpbin.org/get";
    const char* url = "https://blockstream.info/api/tx/d1c789a9c60383bf715f3f6ad9d14b91fe55f3deb369fe5d9280cb1a01793f81/hex";
    char response[10000] = {0};
    char* expected_response = "0100000002137c53f0fb48f83666fcfd2fe9f12d13e94ee109c5aeabbfa32bb9e02538f4cb000000006a47304402207e6009ad86367fc4b166bc80bf10cf1e78832a01e9bb491c6d126ee8aa436cb502200e29e6dd7708ed419cd5ba798981c960f0cc811b24e894bff072fea8074a7c4c012103bc9e7397f739c70f424aa7dcce9d2e521eb228b0ccba619cd6a0b9691da796a1ffffffff517472e77bc29ae59a914f55211f05024556812a2dd7d8df293265acd8330159010000006b483045022100f4bfdb0b3185c778cf28acbaf115376352f091ad9e27225e6f3f350b847579c702200d69177773cd2bb993a816a5ae08e77a6270cf46b33f8f79d45b0cd1244d9c4c0121031c0b0b95b522805ea9d0225b1946ecaeb1727c0b36c7e34165769fd8ed860bf5ffffffff027a958802000000001976a914a802fc56c704ce87c42d7c92eb75e7896bdc41ae88aca5515e00000000001976a914e82bd75c9c662c3f5700b33fec8a676b6e9391d588ac00000000";
    http_get(url, response);
    mu_assert("Error: http_get doesn't work", memcmp((const char*)response, (const char*)expected_response, 746) == 0);
    return 0;
}

static char* test_fee() {
    unsigned char raw_tx_1[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* tx_1 = Tx_parse(raw_tx_1, FALSE);
    unsigned long long fee_1 = fee(tx_1, FALSE);
    mu_assert("Error: fee doesn't work", fee_1 == 40000);
    Tx_free(tx_1);

    unsigned char raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x04, 0x56, 0x91, 0x99, 0x60, 0xac, 0x69, 0x17, 0x63, 0x68, 0x8d, 0x3d, 0x3b, 0xce, 0xa9, 0xad, 0x6e, 0xca, 0xf8, 0x75, 0xdf, 0x53, 0x39, 0xe1, 0x48, 0xa1, 0xfc, 0x61, 0xc6, 0xed, 0x7a, 0x06, 0x9e, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x45, 0x85, 0xbc, 0xde, 0xf8, 0x5e, 0x6b, 0x1c, 0x6a, 0xf5, 0xc2, 0x66, 0x9d, 0x48, 0x30, 0xff, 0x86, 0xe4, 0x2d, 0xd2, 0x05, 0xc0, 0xe0, 0x89, 0xbc, 0x2a, 0x82, 0x16, 0x57, 0xe9, 0x51, 0xc0, 0x02, 0x20, 0x10, 0x24, 0xa1, 0x03, 0x66, 0x07, 0x7f, 0x87, 0xd6, 0xbc, 0xe1, 0xf7, 0x10, 0x0a, 0xd8, 0xcf, 0xa8, 0xa0, 0x64, 0xb3, 0x9d, 0x4e, 0x8f, 0xe4, 0xea, 0x13, 0xa7, 0xb7, 0x1a, 0xa8, 0x18, 0x0f, 0x01, 0x21, 0x02, 0xf0, 0xda, 0x57, 0xe8, 0x5e, 0xec, 0x29, 0x34, 0xa8, 0x2a, 0x58, 0x5e, 0xa3, 0x37, 0xce, 0x2f, 0x49, 0x98, 0xb5, 0x0a, 0xe6, 0x99, 0xdd, 0x79, 0xf5, 0x88, 0x0e, 0x25, 0x3d, 0xaf, 0xaf, 0xb7, 0xfe, 0xff, 0xff, 0xff, 0xeb, 0x8f, 0x51, 0xf4, 0x03, 0x8d, 0xc1, 0x7e, 0x63, 0x13, 0xcf, 0x83, 0x1d, 0x4f, 0x02, 0x28, 0x1c, 0x2a, 0x46, 0x8b, 0xde, 0x0f, 0xaf, 0xd3, 0x7f, 0x1b, 0xf8, 0x82, 0x72, 0x9e, 0x7f, 0xd3, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37, 0xfe, 0xff, 0xff, 0xff, 0x56, 0x7b, 0xf4, 0x05, 0x95, 0x11, 0x9d, 0x1b, 0xb8, 0xa3, 0x03, 0x7c, 0x35, 0x6e, 0xfd, 0x56, 0x17, 0x0b, 0x64, 0xcb, 0xcc, 0x16, 0x0f, 0xb0, 0x28, 0xfa, 0x10, 0x70, 0x4b, 0x45, 0xd7, 0x75, 0x00, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x4c, 0x7c, 0x78, 0x18, 0x42, 0x4c, 0x7f, 0x79, 0x11, 0xda, 0x6c, 0xdd, 0xc5, 0x96, 0x55, 0xa7, 0x0a, 0xf1, 0xcb, 0x5e, 0xaf, 0x17, 0xc6, 0x9d, 0xad, 0xbf, 0xc7, 0x4f, 0xfa, 0x0b, 0x66, 0x2f, 0x02, 0x20, 0x75, 0x99, 0xe0, 0x8b, 0xc8, 0x02, 0x36, 0x93, 0xad, 0x4e, 0x95, 0x27, 0xdc, 0x42, 0xc3, 0x42, 0x10, 0xf7, 0xa7, 0xd1, 0xd1, 0xdd, 0xfc, 0x84, 0x92, 0xb6, 0x54, 0xa1, 0x1e, 0x76, 0x20, 0xa0, 0x01, 0x21, 0x02, 0x15, 0x8b, 0x46, 0xfb, 0xdf, 0xf6, 0x5d, 0x01, 0x72, 0xb7, 0x98, 0x9a, 0xec, 0x88, 0x50, 0xaa, 0x0d, 0xae, 0x49, 0xab, 0xfb, 0x84, 0xc8, 0x1a, 0xe6, 0xe5, 0xb2, 0x51, 0xa5, 0x8a, 0xce, 0x5c, 0xfe, 0xff, 0xff, 0xff, 0xd6, 0x3a, 0x5e, 0x6c, 0x16, 0xe6, 0x20, 0xf8, 0x6f, 0x37, 0x59, 0x25, 0xb2, 0x1c, 0xab, 0xaf, 0x73, 0x6c, 0x77, 0x9f, 0x88, 0xfd, 0x04, 0xdc, 0xad, 0x51, 0xd2, 0x66, 0x90, 0xf7, 0xf3, 0x45, 0x01, 0x00, 0x00, 0x00, 0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x06, 0x33, 0xea, 0x0d, 0x33, 0x14, 0xbe, 0xa0, 0xd9, 0x5b, 0x3c, 0xd8, 0xda, 0xdb, 0x2e, 0xf7, 0x9e, 0xa8, 0x33, 0x1f, 0xfe, 0x1e, 0x61, 0xf7, 0x62, 0xc0, 0xf6, 0xda, 0xea, 0x0f, 0xab, 0xde, 0x02, 0x20, 0x29, 0xf2, 0x3b, 0x3e, 0x9c, 0x30, 0xf0, 0x80, 0x44, 0x61, 0x50, 0xb2, 0x38, 0x52, 0x02, 0x87, 0x51, 0x63, 0x5d, 0xce, 0xe2, 0xbe, 0x66, 0x9c, 0x2a, 0x16, 0x86, 0xa4, 0xb5, 0xed, 0xf3, 0x04, 0x01, 0x21, 0x03, 0xff, 0xd6, 0xf4, 0xa6, 0x7e, 0x94, 0xab, 0xa3, 0x53, 0xa0, 0x08, 0x82, 0xe5, 0x63, 0xff, 0x27, 0x22, 0xeb, 0x4c, 0xff, 0x0a, 0xd6, 0x00, 0x6e, 0x86, 0xee, 0x20, 0xdf, 0xe7, 0x52, 0x0d, 0x55, 0xfe, 0xff, 0xff, 0xff, 0x02, 0x51, 0x43, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xab, 0x0c, 0x0b, 0x2e, 0x98, 0xb1, 0xab, 0x6d, 0xbf, 0x67, 0xd4, 0x75, 0x0b, 0x0a, 0x56, 0x24, 0x49, 0x48, 0xa8, 0x79, 0x88, 0xac, 0x00, 0x5a, 0x62, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x3c, 0x82, 0xd7, 0xdf, 0x36, 0x4e, 0xb6, 0xc7, 0x5b, 0xe8, 0xc8, 0x0d, 0xf2, 0xb3, 0xed, 0xa8, 0xdb, 0x57, 0x39, 0x70, 0x88, 0xac, 0x46, 0x43, 0x06, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, FALSE);
    unsigned long long fee_2 = fee(tx_2, FALSE);
    mu_assert("Error: fee doesn't work", fee_2 == 140500);
    Tx_free(tx_2);
    return 0;
}

static char* test_encode_num() {
    long long num_1 = 0;
    unsigned char result_1[1];
    encode_num(num_1, result_1);
    unsigned char expected_result_1[1] = {0x00};
    mu_assert("Error: encode_num doesn't work", memcmp(result_1, expected_result_1, 1) == 0);
    long long num_2 = 252;
    unsigned char result_2[2];
    encode_num(num_2, result_2);
    unsigned char expected_result_2[2] = {0xfc, 0x00};
    mu_assert("Error: encode_num doesn't work", memcmp(result_2, expected_result_2, 1) == 0);
    long long num_3 = -1;
    unsigned char result_3[1];
    encode_num(num_3, result_3);
    unsigned char expected_result_3[1] = {0x81};
    mu_assert("Error: encode_num doesn't work", memcmp(result_3, expected_result_3, 1) == 0);
    long long num_4 = 1098523;
    unsigned char result_4[3];
    encode_num(num_4, result_4);
    unsigned char expected_result_4[3] = {0x1b, 0xc3, 0x10};
    mu_assert("Error: encode_num doesn't work", memcmp(result_4, expected_result_4, 3) == 0);
    long long num_5 = -1098523;
    unsigned char result_5[3];
    encode_num(num_5, result_5);
    unsigned char expected_result_5[3] = {0x1b, 0xc3, 0x90};
    mu_assert("Error: encode_num doesn't work", memcmp(result_5, expected_result_5, 3) == 0);
    long long num_6 = -252;
    unsigned char result_6[2];
    encode_num(num_6, result_6);
    unsigned char expected_result_6[2] = {0xfc, 0x80};
    mu_assert("Error: encode_num doesn't work", memcmp(result_6, expected_result_6, 2) == 0);
    return 0;
}

static char* test_decode_num() {
    unsigned char raw_num_1[] = {0x00};
    long long result_1 = decode_num(raw_num_1, 1);
    long long expected_result_1 = 0;
    mu_assert("Error: decode_num doesn't work", result_1 == expected_result_1);
    unsigned char raw_num_2[] = {0xfc, 0x00};
    long long result_2 = decode_num(raw_num_2, 2);
    long long expected_result_2 = 252;
    mu_assert("Error: decode_num doesn't work", result_2 == expected_result_2);
    unsigned char raw_num_3[] = {0x81};
    long long result_3 = decode_num(raw_num_3, 1);
    long long expected_result_3 = -1;
    mu_assert("Error: decode_num doesn't work", result_3 == expected_result_3);
    unsigned char raw_num_4[] = {0x1b, 0xc3, 0x10};
    long long result_4 = decode_num(raw_num_4, 3);
    long long expected_result_4 = 1098523;
    mu_assert("Error: decode_num doesn't work", result_4 == expected_result_4);
    unsigned char raw_num_5[] = {0x1b, 0xc3, 0x90};
    long long result_5 = decode_num(raw_num_5, 3);
    long long expected_result_5 = -1098523;
    mu_assert("Error: decode_num doesn't work", result_5 == expected_result_5);
    unsigned char raw_num_6[] = {0xfc, 0x80};
    long long result_6 = decode_num(raw_num_6, 2);
    long long expected_result_6 = -252;
    mu_assert("Error: decode_num doesn't work", result_6 == expected_result_6);
    return 0;
}

static char* test_hash160() {
    unsigned char test[11] = "hello world";
    unsigned char result[20];
    hash160(test, 11, result);
    unsigned char expected_result[] = {0xd7, 0xd5, 0xee, 0x78, 0x24, 0xff, 0x93, 0xf9, 0x4c, 0x30, 0x55, 0xaf, 0x93, 0x82, 0xc8, 0x6c, 0x68, 0xb5, 0xca, 0x92};
    mu_assert("Error: hash160 doesn't work", memcmp(result, expected_result, 20) == 0);
    return 0;
}

static char* test_op_hash160() {
    Op* test_op = op_init();
    unsigned char test[11] = "hello world";
    push(test_op, test, 11);
    size_t worked = op_hash160(test_op);
    unsigned char result[20] = {0};
    peek(test_op, result);
    unsigned char expected_result[20] = {0xd7, 0xd5, 0xee, 0x78, 0x24, 0xff, 0x93, 0xf9, 0x4c, 0x30, 0x55, 0xaf, 0x93, 0x82, 0xc8, 0x6c, 0x68, 0xb5, 0xca, 0x92};
    op_free(test_op);
    mu_assert("Error: op_hash160 doesn't work", worked);
    mu_assert("Error: op_hash160 doesn't work", memcmp(result, expected_result, 20) == 0);
    return 0;
}

static char* test_script_parse() {
    unsigned char script_pubkey[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script = script_parse(script_pubkey);
    mu_assert("Error: script_parse doesn't work", script->cmds_len == 2);
    unsigned char want_1[] = {0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01};
    mu_assert("Error: script_parse doesn't work", memcmp(script->cmds[0].data, want_1, 71) == 0);
    unsigned char want_2[] = {0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    mu_assert("Error: script_parse doesn't work", memcmp(script->cmds[1].data, want_2, 33) == 0);
    script_free(script);
    return 0;
}

static char* test_script_serialize() {
    unsigned char want[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script = script_parse(want);
    unsigned char result[107];
    script_serialize(script, result);
    mu_assert("Error: script_serialize doesn't work", memcmp(result, want, 106) == 0);
    script_free(script);
    return 0;
}

static char* test_script_add() {
    unsigned char script_pubkey[] = {0x6a, 0x47, 0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01, 0x21, 0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    Script* script_1 = script_parse(script_pubkey);
    unsigned char script_sig[] = {0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    Script* script_2 = script_parse(script_sig);
    Script* result = script_add(script_1, script_2);
    mu_assert("Error: script_add doesn't work", result->cmds_len == 4);
    unsigned char want_1[] = {0x30, 0x44, 0x02, 0x20, 0x78, 0x99, 0x53, 0x1a, 0x52, 0xd5, 0x9a, 0x6d, 0xe2, 0x00, 0x17, 0x99, 0x28, 0xca, 0x90, 0x02, 0x54, 0xa3, 0x6b, 0x8d, 0xff, 0x8b, 0xb7, 0x5f, 0x5f, 0x5d, 0x71, 0xb1, 0xcd, 0xc2, 0x61, 0x25, 0x02, 0x20, 0x08, 0xb4, 0x22, 0x69, 0x0b, 0x84, 0x61, 0xcb, 0x52, 0xc3, 0xcc, 0x30, 0x33, 0x0b, 0x23, 0xd5, 0x74, 0x35, 0x18, 0x72, 0xb7, 0xc3, 0x61, 0xe9, 0xaa, 0xe3, 0x64, 0x90, 0x71, 0xc1, 0xa7, 0x16, 0x01};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[0].data, want_1, 71) == 0);
    unsigned char want_2[] = {0x03, 0x5d, 0x5c, 0x93, 0xd9, 0xac, 0x96, 0x88, 0x1f, 0x19, 0xba, 0x1f, 0x68, 0x6f, 0x15, 0xf0, 0x09, 0xde, 0xd7, 0xc6, 0x2e, 0xfe, 0x85, 0xa8, 0x72, 0xe6, 0xa1, 0x9b, 0x43, 0xc1, 0x5a, 0x29, 0x37};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[1].data, want_2, 33) == 0);
    unsigned char want_3[] = {0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[2].data, want_3, 72) == 0);
    unsigned char want_4[] = {0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a};
    mu_assert("Error: script_add doesn't work", memcmp(result->cmds[3].data, want_4, 33) == 0);
    script_free(script_1);
    script_free(script_2);
    script_free(result);
    return 0;
}

static char* test_op_checksig() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, 16);
    S256Field* test_z = S256Field_init(test_Z);
    unsigned char sec[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    unsigned char sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    Op* op = op_init();
    push(op, sig, 72);
    push(op, sec, 65);
    size_t checksig = op_checksig(op, test_z);
    mu_assert("Error: op_checksig doesn't work", checksig);
    long long num = decode_num(op->stack[0], 1);
    mu_assert("Error: op_checksig doesn't work", num == 1);
    op_free(op);
    S256Field_free(test_z);
    return 0;
}

static char* test_script_evaluate() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, 16);
    S256Field* test_z = S256Field_init(test_Z);

    Command cmd_1;
    cmd_1.data[0] = 0x76;
    cmd_1.data_len = 1;
    Command cmd_2;
    cmd_2.data[0] = 0x76;
    cmd_2.data_len = 1;
    Command cmd_3;
    cmd_3.data[0] = 0x95;
    cmd_3.data_len = 1;
    Command cmd_4;
    cmd_4.data[0] = 0x93;
    cmd_4.data_len = 1;
    Command cmd_5;
    cmd_5.data[0] = 0x56;
    cmd_5.data_len = 1;
    Command cmd_6;
    cmd_6.data[0] = 0x87;
    cmd_6.data_len = 1;
    Command cmd_7;
    cmd_7.data[0] = 0x52;
    cmd_7.data_len = 1;

    Command cmds_1[6] = {cmd_1, cmd_2, cmd_3, cmd_4, cmd_5, cmd_6};
    Script* script_1 = script_init();
    script_set_cmds(script_1, cmds_1, 6);
    Command cmds_2[1] = {cmd_7};
    Script* script_2 = script_init();
    script_set_cmds(script_2, cmds_2, 1);
    Script* combined_script_1 = script_add(script_2, script_1);
    size_t worked_2 = script_evaluate(combined_script_1, test_z);
    mu_assert("Error: script_evaluate doesn't work", worked_2);
    script_free(script_1);
    script_free(script_2);
    script_free(combined_script_1);

    Command cmd_8;
    cmd_8.data[0] = 0x6e;
    cmd_8.data_len = 1;
    Command cmd_9;
    cmd_9.data[0] = 0x87;
    cmd_9.data_len = 1;
    Command cmd_10;
    cmd_10.data[0] = 0x91;
    cmd_10.data_len = 1;
    Command cmd_11;
    cmd_11.data[0] = 0x69;
    cmd_11.data_len = 1;
    Command cmd_12;
    cmd_12.data[0] = 0xa7;
    cmd_12.data_len = 1;
    Command cmd_13;
    cmd_13.data[0] = 0x7c;
    cmd_13.data_len = 1;
    Command cmd_14;
    cmd_14.data[0] = 0xa7;
    cmd_14.data_len = 1;
    Command cmd_15;
    cmd_15.data[0] = 0x87;
    cmd_15.data_len = 1;

    Command cmds_3[8] = {cmd_8, cmd_9, cmd_10, cmd_11, cmd_12, cmd_13, cmd_14, cmd_15};
    Script* scriptpubkey = script_init();
    script_set_cmds(scriptpubkey, cmds_3, 8);
    unsigned char c1[320] = {0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x33, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x0a, 0x0a, 0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x2f, 0x57, 0x69, 0x64, 0x74, 0x68, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x33, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x34, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x20, 0x35, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x20, 0x36, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x53, 0x70, 0x61, 0x63, 0x65, 0x20, 0x37, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x38, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x42, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x38, 0x3e, 0x3e, 0x0a, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x0a, 0xff, 0xd8, 0xff, 0xfe, 0x00, 0x24, 0x53, 0x48, 0x41, 0x2d, 0x31, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x61, 0x64, 0x21, 0x21, 0x21, 0x21, 0x21, 0x85, 0x2f, 0xec, 0x09, 0x23, 0x39, 0x75, 0x9c, 0x39, 0xb1, 0xa1, 0xc6, 0x3c, 0x4c, 0x97, 0xe1, 0xff, 0xfe, 0x01, 0x7f, 0x46, 0xdc, 0x93, 0xa6, 0xb6, 0x7e, 0x01, 0x3b, 0x02, 0x9a, 0xaa, 0x1d, 0xb2, 0x56, 0x0b, 0x45, 0xca, 0x67, 0xd6, 0x88, 0xc7, 0xf8, 0x4b, 0x8c, 0x4c, 0x79, 0x1f, 0xe0, 0x2b, 0x3d, 0xf6, 0x14, 0xf8, 0x6d, 0xb1, 0x69, 0x09, 0x01, 0xc5, 0x6b, 0x45, 0xc1, 0x53, 0x0a, 0xfe, 0xdf, 0xb7, 0x60, 0x38, 0xe9, 0x72, 0x72, 0x2f, 0xe7, 0xad, 0x72, 0x8f, 0x0e, 0x49, 0x04, 0xe0, 0x46, 0xc2, 0x30, 0x57, 0x0f, 0xe9, 0xd4, 0x13, 0x98, 0xab, 0xe1, 0x2e, 0xf5, 0xbc, 0x94, 0x2b, 0xe3, 0x35, 0x42, 0xa4, 0x80, 0x2d, 0x98, 0xb5, 0xd7, 0x0f, 0x2a, 0x33, 0x2e, 0xc3, 0x7f, 0xac, 0x35, 0x14, 0xe7, 0x4d, 0xdc, 0x0f, 0x2c, 0xc1, 0xa8, 0x74, 0xcd, 0x0c, 0x78, 0x30, 0x5a, 0x21, 0x56, 0x64, 0x61, 0x30, 0x97, 0x89, 0x60, 0x6b, 0xd0, 0xbf, 0x3f, 0x98, 0xcd, 0xa8, 0x04, 0x46, 0x29, 0xa1};
    unsigned char c2[320] = {0x25, 0x50, 0x44, 0x46, 0x2d, 0x31, 0x2e, 0x33, 0x0a, 0x25, 0xe2, 0xe3, 0xcf, 0xd3, 0x0a, 0x0a, 0x0a, 0x31, 0x20, 0x30, 0x20, 0x6f, 0x62, 0x6a, 0x0a, 0x3c, 0x3c, 0x2f, 0x57, 0x69, 0x64, 0x74, 0x68, 0x20, 0x32, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74, 0x20, 0x33, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x54, 0x79, 0x70, 0x65, 0x20, 0x34, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x53, 0x75, 0x62, 0x74, 0x79, 0x70, 0x65, 0x20, 0x35, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x20, 0x36, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x43, 0x6f, 0x6c, 0x6f, 0x72, 0x53, 0x70, 0x61, 0x63, 0x65, 0x20, 0x37, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x20, 0x38, 0x20, 0x30, 0x20, 0x52, 0x2f, 0x42, 0x69, 0x74, 0x73, 0x50, 0x65, 0x72, 0x43, 0x6f, 0x6d, 0x70, 0x6f, 0x6e, 0x65, 0x6e, 0x74, 0x20, 0x38, 0x3e, 0x3e, 0x0a, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x0a, 0xff, 0xd8, 0xff, 0xfe, 0x00, 0x24, 0x53, 0x48, 0x41, 0x2d, 0x31, 0x20, 0x69, 0x73, 0x20, 0x64, 0x65, 0x61, 0x64, 0x21, 0x21, 0x21, 0x21, 0x21, 0x85, 0x2f, 0xec, 0x09, 0x23, 0x39, 0x75, 0x9c, 0x39, 0xb1, 0xa1, 0xc6, 0x3c, 0x4c, 0x97, 0xe1, 0xff, 0xfe, 0x01, 0x73, 0x46, 0xdc, 0x91, 0x66, 0xb6, 0x7e, 0x11, 0x8f, 0x02, 0x9a, 0xb6, 0x21, 0xb2, 0x56, 0x0f, 0xf9, 0xca, 0x67, 0xcc, 0xa8, 0xc7, 0xf8, 0x5b, 0xa8, 0x4c, 0x79, 0x03, 0x0c, 0x2b, 0x3d, 0xe2, 0x18, 0xf8, 0x6d, 0xb3, 0xa9, 0x09, 0x01, 0xd5, 0xdf, 0x45, 0xc1, 0x4f, 0x26, 0xfe, 0xdf, 0xb3, 0xdc, 0x38, 0xe9, 0x6a, 0xc2, 0x2f, 0xe7, 0xbd, 0x72, 0x8f, 0x0e, 0x45, 0xbc, 0xe0, 0x46, 0xd2, 0x3c, 0x57, 0x0f, 0xeb, 0x14, 0x13, 0x98, 0xbb, 0x55, 0x2e, 0xf5, 0xa0, 0xa8, 0x2b, 0xe3, 0x31, 0xfe, 0xa4, 0x80, 0x37, 0xb8, 0xb5, 0xd7, 0x1f, 0x0e, 0x33, 0x2e, 0xdf, 0x93, 0xac, 0x35, 0x00, 0xeb, 0x4d, 0xdc, 0x0d, 0xec, 0xc1, 0xa8, 0x64, 0x79, 0x0c, 0x78, 0x2c, 0x76, 0x21, 0x56, 0x60, 0xdd, 0x30, 0x97, 0x91, 0xd0, 0x6b, 0xd0, 0xaf, 0x3f, 0x98, 0xcd, 0xa4, 0xbc, 0x46, 0x29, 0xb1};
    Command cmd_c1;
    memcpy(cmd_c1.data, c1, 320);
    cmd_c1.data_len = 320;
    Command cmd_c2;
    memcpy(cmd_c2.data, c2, 320);
    cmd_c2.data_len = 320;
    Command cmds_4[2] = {cmd_c1, cmd_c2};
    Script* scriptsig = script_init();
    script_set_cmds(scriptsig, cmds_4, 2);
    Script* combined_script_2 = script_add(scriptsig, scriptpubkey);
    size_t worked_3 = script_evaluate(combined_script_2, test_z);
    mu_assert("Error: script_evaluate doesn't work", worked_3);
    script_free(scriptpubkey);
    script_free(scriptsig);
    script_free(combined_script_2);
    S256Field_free(test_z);
    return 0;
}

static char* test_p2pk() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, 16);
    S256Field* test_z = S256Field_init(test_Z);
    unsigned char sec[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    unsigned char sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    Command cmd_pubkey;
    memcpy(cmd_pubkey.data, sec, 65);
    cmd_pubkey.data_len = 65;
    Command cmd_sig;
    memcpy(cmd_sig.data, sig, 72);
    cmd_sig.data_len = 72;
    Command cmd;
    cmd.data[0] = 0xac;
    cmd.data_len = 1;
    Command cmds_pubkey[2] = {cmd_pubkey, cmd};
    Script* script_pubkey = script_init();
    script_set_cmds(script_pubkey, cmds_pubkey, 2);
    Command cmds_sig[1] = {cmd_sig};
    Script* script_sig = script_init();
    script_set_cmds(script_sig, cmds_sig, 1);
    Script* combined_script = script_add(script_sig, script_pubkey);
    size_t worked = script_evaluate(combined_script, test_z);
    mu_assert("Error: script_evaluate doesn't work", worked);
    script_free(script_sig);
    script_free(script_pubkey);
    script_free(combined_script);
    S256Field_free(test_z);
    return 0;
}

static char* test_p2pkh() {
    mpz_t test_Z;
    mpz_init_set_str(test_Z, TEST_Z_2, 16);
    S256Field* test_z = S256Field_init(test_Z);
    unsigned char hash[20] = {0xe2, 0x95, 0x1e, 0x00, 0x7b, 0x83, 0x4e, 0xb6, 0x1e, 0x99, 0x5d, 0xe8, 0x12, 0x2b, 0x6d, 0x3a, 0xfe, 0xce, 0xeb, 0x42};
    unsigned char sig[72] = {0x30, 0x45, 0x02, 0x20, 0x00, 0xef, 0xf6, 0x9e, 0xf2, 0xb1, 0xbd, 0x93, 0xa6, 0x6e, 0xd5, 0x21, 0x9a, 0xdd, 0x4f, 0xb5, 0x1e, 0x11, 0xa8, 0x40, 0xf4, 0x04, 0x87, 0x63, 0x25, 0xa1, 0xe8, 0xff, 0xe0, 0x52, 0x9a, 0x2c, 0x02, 0x21, 0x00, 0xc7, 0x20, 0x7f, 0xee, 0x19, 0x7d, 0x27, 0xc6, 0x18, 0xae, 0xa6, 0x21, 0x40, 0x6f, 0x6b, 0xf5, 0xef, 0x6f, 0xca, 0x38, 0x68, 0x1d, 0x82, 0xb2, 0xf0, 0x6f, 0xdd, 0xbd, 0xce, 0x6f, 0xea, 0xb6, 0x01};
    unsigned char pubkey[65] = {0x04, 0x88, 0x73, 0x87, 0xe4, 0x52, 0xb8, 0xea, 0xcc, 0x4a, 0xcf, 0xde, 0x10, 0xd9, 0xaa, 0xf7, 0xf6, 0xd9, 0xa0, 0xf9, 0x75, 0xaa, 0xbb, 0x10, 0xd0, 0x06, 0xe4, 0xda, 0x56, 0x87, 0x44, 0xd0, 0x6c, 0x61, 0xde, 0x6d, 0x95, 0x23, 0x1c, 0xd8, 0x90, 0x26, 0xe2, 0x86, 0xdf, 0x3b, 0x6a, 0xe4, 0xa8, 0x94, 0xa3, 0x37, 0x8e, 0x39, 0x3e, 0x93, 0xa0, 0xf4, 0x5b, 0x66, 0x63, 0x29, 0xa0, 0xae, 0x34};
    Command cmd_opdup;
    cmd_opdup.data[0] = 0x76;
    cmd_opdup.data_len = 1;
    Command cmd_ophash160;
    cmd_ophash160.data[0] = 0xa9;
    cmd_ophash160.data_len = 1;
    Command cmd_hash;
    memcpy(cmd_hash.data, hash, 20);
    cmd_hash.data_len = 20;
    Command cmd_opequalverify;
    cmd_opequalverify.data[0] = 0x88;
    cmd_opequalverify.data_len = 1;
    Command cmd_opchecksig;
    cmd_opchecksig.data[0] = 0xac;
    cmd_opchecksig.data_len = 1;
    Command cmds_pubkey[5] = {cmd_opdup, cmd_ophash160, cmd_hash, cmd_opequalverify, cmd_opchecksig};
    Script* scriptpubkey = script_init();
    script_set_cmds(scriptpubkey, cmds_pubkey, 5);
    Command cmd_sig;
    memcpy(cmd_sig.data, sig, 72);
    cmd_sig.data_len = 72;
    Command cmd_pubkey;
    memcpy(cmd_pubkey.data, pubkey, 65);
    cmd_pubkey.data_len = 65;
    Command cmds_sig[2] = {cmd_sig, cmd_pubkey};
    Script* scriptsig = script_init();
    script_set_cmds(scriptsig, cmds_sig, 2);
    Script* combined_script = script_add(scriptsig, scriptpubkey);
    size_t worked = script_evaluate(combined_script, test_z);
    mu_assert("Error: script_evaluate doesn't work", worked);
    script_free(scriptpubkey);
    script_free(scriptsig);
    script_free(combined_script);
    S256Field_free(test_z);
    return 0;
}

static char* test_find_differences() {
    const char* s1 = "0100000001c228021e1fee6f158cc506edea6bad7ffa421dd14fb7fd7e01c50cc9693e8dbe02000000fdfe0000483045022100c679944ff8f20373685e1122b581f64752c1d22c67f6f3ae26333aa9c3f43d730220793233401f87f640f9c39207349ffef42d0e27046755263c0a69c436ab07febc01483045022100eadc1c6e72f241c3e076a7109b8053db53987f3fcc99e3f88fc4e52dbfd5f3a202201f02cbff194c41e6f8da762e024a7ab85c1b1616b74720f13283043e9e99dab8014c69522102b0c7be446b92624112f3c7d4ffc214921c74c1cb891bf945c49fbe5981ee026b21039021c9391e328e0cb3b61ba05dcc5e122ab234e55d1502e59b10d8f588aea4632102f3bd8f64363066f35968bd82ed9c6e8afecbd6136311bb51e91204f614144e9b53aeffffffff05a08601000000000017a914081fbb6ec9d83104367eb1a6a59e2a92417d79298700350c00000000001976a914677345c7376dfda2c52ad9b6a153b643b6409a3788acc7f341160000000017a914234c15756b9599314c9299340eaabab7f1810d8287c02709000000000017a91469be3ca6195efcab5194e1530164ec47637d44308740420f00000000001976a91487fadba66b9e48c0c8082f33107fdb01970eb80388ac00000000";
    const char* s2 = "0100000001c228021e1fee6f158cc506edea6bad7ffa421dd14fb7fd7e01c50cc9693e8dbe02000000fdfe0000483045022100c679944ff8f20373685e1122b581f64752c1d22c67f6f3ae26333aa9c3f43d730220793233401f87f640f9c39207349ffef42d0e27046755263c0a69c436ab07febc01483045022100eadc1c6e72f241c3e076a7109b8053db53987f3fcc99e3f88fc4e52dbfd5f3a202201f02cbff194c41e6f8da762e024a7ab85c1b1616b74720f13283043e9e99dab8014c69522102b0c7be446b92624112f3c7d4ffc214921c74c1cb891bf945c49fbe5981ee026b21039021c9391e328e0cb3b61ba05dcc5e122ab234e55d1502e59b10d8f588aea4632102f3bd8f64363066f35968bd82ed9c6e8afecbd6136311bb51e91204f614144e9b53aeffffffff05a08601000000000017a914081fbb6ec9d83104367eb1a6a59e2a92417d79298700350c00000000001976a914677345c7376dfda2c52ad9b6a153b643b6409a3788acc7f341160000000017a914234c15756b9599314c9299340eaabab7f1810d8287c02709000000000017a91469be3ca6195efcab5194e1530164ec47637d44308740420f00000000001976a91487fadba66b9e48c0c8082f33107fdb01970eb80388ac000000";
    find_differences(s1, s2);
    return 0;
}

static char* test_hex_string_to_byte_array() {
    char* string = "0100000001d1c789a9c60383bf715f3f6ad9d14b91fe55f3deb369fe5d9280cb1a01793f81000000006b483045022100ed81ff192e75a3fd2304004dcadb746fa5e24c5031ccfcf21320b0277457c98f02207a986d955c6e0cb35d446a89d3f56100f4d7f67801c31967743a9c8e10615bed01210349fc4e631e3624a545de3f89f5d8684c7b8138bd94bdd531d2e213bf016b278afeffffff02a135ef01000000001976a914bc3b654dca7e56b04dca18f2566cdaf02e8d9ada88ac99c39800000000001976a9141c4bc762dd5423e332166702cb75f40df79fea1288ac19430600";
    unsigned char expected_result[226] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xd1, 0xc7, 0x89, 0xa9, 0xc6, 0x03, 0x83, 0xbf, 0x71, 0x5f, 0x3f, 0x6a, 0xd9, 0xd1, 0x4b, 0x91, 0xfe, 0x55, 0xf3, 0xde, 0xb3, 0x69, 0xfe, 0x5d, 0x92, 0x80, 0xcb, 0x1a, 0x01, 0x79, 0x3f, 0x81, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    unsigned char result[226] = {0};
    hex_string_to_byte_array(string, result);
    mu_assert("Error: hex_string_to_byte_array doesn't work", memcmp(result, expected_result, 226) == 0);
    return 0;
}

static char* test_tx_id() {
    unsigned char raw_tx_1[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x81, 0x3f, 0x79, 0x01, 0x1a, 0xcb, 0x80, 0x92, 0x5d, 0xfe, 0x69, 0xb3, 0xde, 0xf3, 0x55, 0xfe, 0x91, 0x4b, 0xd1, 0xd9, 0x6a, 0x3f, 0x5f, 0x71, 0xbf, 0x83, 0x03, 0xc6, 0xa9, 0x89, 0xc7, 0xd1, 0x00, 0x00, 0x00, 0x00, 0x6b, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xed, 0x81, 0xff, 0x19, 0x2e, 0x75, 0xa3, 0xfd, 0x23, 0x04, 0x00, 0x4d, 0xca, 0xdb, 0x74, 0x6f, 0xa5, 0xe2, 0x4c, 0x50, 0x31, 0xcc, 0xfc, 0xf2, 0x13, 0x20, 0xb0, 0x27, 0x74, 0x57, 0xc9, 0x8f, 0x02, 0x20, 0x7a, 0x98, 0x6d, 0x95, 0x5c, 0x6e, 0x0c, 0xb3, 0x5d, 0x44, 0x6a, 0x89, 0xd3, 0xf5, 0x61, 0x00, 0xf4, 0xd7, 0xf6, 0x78, 0x01, 0xc3, 0x19, 0x67, 0x74, 0x3a, 0x9c, 0x8e, 0x10, 0x61, 0x5b, 0xed, 0x01, 0x21, 0x03, 0x49, 0xfc, 0x4e, 0x63, 0x1e, 0x36, 0x24, 0xa5, 0x45, 0xde, 0x3f, 0x89, 0xf5, 0xd8, 0x68, 0x4c, 0x7b, 0x81, 0x38, 0xbd, 0x94, 0xbd, 0xd5, 0x31, 0xd2, 0xe2, 0x13, 0xbf, 0x01, 0x6b, 0x27, 0x8a, 0xfe, 0xff, 0xff, 0xff, 0x02, 0xa1, 0x35, 0xef, 0x01, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xbc, 0x3b, 0x65, 0x4d, 0xca, 0x7e, 0x56, 0xb0, 0x4d, 0xca, 0x18, 0xf2, 0x56, 0x6c, 0xda, 0xf0, 0x2e, 0x8d, 0x9a, 0xda, 0x88, 0xac, 0x99, 0xc3, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x1c, 0x4b, 0xc7, 0x62, 0xdd, 0x54, 0x23, 0xe3, 0x32, 0x16, 0x67, 0x02, 0xcb, 0x75, 0xf4, 0x0d, 0xf7, 0x9f, 0xea, 0x12, 0x88, 0xac, 0x19, 0x43, 0x06, 0x00};
    Tx* tx_1 = Tx_parse(raw_tx_1, FALSE);
    unsigned char result[32] = {0};
    unsigned char expected_result[32] = {0x45, 0x2c, 0x62, 0x9d, 0x67, 0xe4, 0x1b, 0xae, 0xc3, 0xac, 0x6f, 0x04, 0xfe, 0x74, 0x4b, 0x4b, 0x96, 0x17, 0xf8, 0xf8, 0x59, 0xc6, 0x3b, 0x30, 0x02, 0xf8, 0x68, 0x4e, 0x7a, 0x4f, 0xee, 0x03};
    Tx_id(tx_1, result);
    mu_assert("Error: Tx_id doesn't work", memcmp(result, expected_result, 32) == 0);
    Tx_free(tx_1);

    unsigned char raw_tx_2[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0xc2, 0x28, 0x02, 0x1e, 0x1f, 0xee, 0x6f, 0x15, 0x8c, 0xc5, 0x06, 0xed, 0xea, 0x6b, 0xad, 0x7f, 0xfa, 0x42, 0x1d, 0xd1, 0x4f, 0xb7, 0xfd, 0x7e, 0x01, 0xc5, 0x0c, 0xc9, 0x69, 0x3e, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0x00, 0xfd, 0xfe, 0x00, 0x00, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xc6, 0x79, 0x94, 0x4f, 0xf8, 0xf2, 0x03, 0x73, 0x68, 0x5e, 0x11, 0x22, 0xb5, 0x81, 0xf6, 0x47, 0x52, 0xc1, 0xd2, 0x2c, 0x67, 0xf6, 0xf3, 0xae, 0x26, 0x33, 0x3a, 0xa9, 0xc3, 0xf4, 0x3d, 0x73, 0x02, 0x20, 0x79, 0x32, 0x33, 0x40, 0x1f, 0x87, 0xf6, 0x40, 0xf9, 0xc3, 0x92, 0x07, 0x34, 0x9f, 0xfe, 0xf4, 0x2d, 0x0e, 0x27, 0x04, 0x67, 0x55, 0x26, 0x3c, 0x0a, 0x69, 0xc4, 0x36, 0xab, 0x07, 0xfe, 0xbc, 0x01, 0x48, 0x30, 0x45, 0x02, 0x21, 0x00, 0xea, 0xdc, 0x1c, 0x6e, 0x72, 0xf2, 0x41, 0xc3, 0xe0, 0x76, 0xa7, 0x10, 0x9b, 0x80, 0x53, 0xdb, 0x53, 0x98, 0x7f, 0x3f, 0xcc, 0x99, 0xe3, 0xf8, 0x8f, 0xc4, 0xe5, 0x2d, 0xbf, 0xd5, 0xf3, 0xa2, 0x02, 0x20, 0x1f, 0x02, 0xcb, 0xff, 0x19, 0x4c, 0x41, 0xe6, 0xf8, 0xda, 0x76, 0x2e, 0x02, 0x4a, 0x7a, 0xb8, 0x5c, 0x1b, 0x16, 0x16, 0xb7, 0x47, 0x20, 0xf1, 0x32, 0x83, 0x04, 0x3e, 0x9e, 0x99, 0xda, 0xb8, 0x01, 0x4c, 0x69, 0x52, 0x21, 0x02, 0xb0, 0xc7, 0xbe, 0x44, 0x6b, 0x92, 0x62, 0x41, 0x12, 0xf3, 0xc7, 0xd4, 0xff, 0xc2, 0x14, 0x92, 0x1c, 0x74, 0xc1, 0xcb, 0x89, 0x1b, 0xf9, 0x45, 0xc4, 0x9f, 0xbe, 0x59, 0x81, 0xee, 0x02, 0x6b, 0x21, 0x03, 0x90, 0x21, 0xc9, 0x39, 0x1e, 0x32, 0x8e, 0x0c, 0xb3, 0xb6, 0x1b, 0xa0, 0x5d, 0xcc, 0x5e, 0x12, 0x2a, 0xb2, 0x34, 0xe5, 0x5d, 0x15, 0x02, 0xe5, 0x9b, 0x10, 0xd8, 0xf5, 0x88, 0xae, 0xa4, 0x63, 0x21, 0x02, 0xf3, 0xbd, 0x8f, 0x64, 0x36, 0x30, 0x66, 0xf3, 0x59, 0x68, 0xbd, 0x82, 0xed, 0x9c, 0x6e, 0x8a, 0xfe, 0xcb, 0xd6, 0x13, 0x63, 0x11, 0xbb, 0x51, 0xe9, 0x12, 0x04, 0xf6, 0x14, 0x14, 0x4e, 0x9b, 0x53, 0xae, 0xff, 0xff, 0xff, 0xff, 0x05, 0xa0, 0x86, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x08, 0x1f, 0xbb, 0x6e, 0xc9, 0xd8, 0x31, 0x04, 0x36, 0x7e, 0xb1, 0xa6, 0xa5, 0x9e, 0x2a, 0x92, 0x41, 0x7d, 0x79, 0x29, 0x87, 0x00, 0x35, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x67, 0x73, 0x45, 0xc7, 0x37, 0x6d, 0xfd, 0xa2, 0xc5, 0x2a, 0xd9, 0xb6, 0xa1, 0x53, 0xb6, 0x43, 0xb6, 0x40, 0x9a, 0x37, 0x88, 0xac, 0xc7, 0xf3, 0x41, 0x16, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x23, 0x4c, 0x15, 0x75, 0x6b, 0x95, 0x99, 0x31, 0x4c, 0x92, 0x99, 0x34, 0x0e, 0xaa, 0xba, 0xb7, 0xf1, 0x81, 0x0d, 0x82, 0x87, 0xc0, 0x27, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xa9, 0x14, 0x69, 0xbe, 0x3c, 0xa6, 0x19, 0x5e, 0xfc, 0xab, 0x51, 0x94, 0xe1, 0x53, 0x01, 0x64, 0xec, 0x47, 0x63, 0x7d, 0x44, 0x30, 0x87, 0x40, 0x42, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0x87, 0xfa, 0xdb, 0xa6, 0x6b, 0x9e, 0x48, 0xc0, 0xc8, 0x08, 0x2f, 0x33, 0x10, 0x7f, 0xdb, 0x01, 0x97, 0x0e, 0xb8, 0x03, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00};
    Tx* tx_2 = Tx_parse(raw_tx_2, FALSE);
    unsigned char result_2[32] = {0};
    unsigned char expected_result_2[32] = {0x9e, 0x06, 0x7a, 0xed, 0xc6, 0x61, 0xfc, 0xa1, 0x48, 0xe1, 0x39, 0x53, 0xdf, 0x75, 0xf8, 0xca, 0x6e, 0xad, 0xa9, 0xce, 0x3b, 0x3d, 0x8d, 0x68, 0x63, 0x17, 0x69, 0xac, 0x60, 0x99, 0x91, 0x56};
    Tx_id(tx_2, result_2);
    mu_assert("Error: Tx_id doesn't work", memcmp(result_2, expected_result_2, 32) == 0);
    Tx_free(tx_2);
    return 0;
}

static char* all_tests() {
    // // //S256Field tests
    // mu_run_test(test_S256Field_add);
    // mu_run_test(test_S256Field_sub);
    // mu_run_test(test_S256Field_mul);
    // mu_run_test(test_S256Field_s_mul);
    // mu_run_test(test_S256Field_mul_scalar);
    // mu_run_test(test_S256Field_mod_inv);
    // mu_run_test(test_S256Field_s_inv);
    // mu_run_test(test_S256Field_pow);
    // mu_run_test(test_S256Field_div);
    // mu_run_test(test_S256Field_sqrt);
    
    // // //S256Point tests
    // mu_run_test(test_S256Point_add);
    // mu_run_test(test_S256Point_mul);
    // mu_run_test(test_S256Point_verify);
    // mu_run_test(test_S256Point_sec_uncompressed);
    // mu_run_test(test_S256Point_sec_compressed);
    // mu_run_test(test_S256Point_parse_sec);
    // mu_run_test(test_S256Point_address);

    // // //Private Key tests
    // mu_run_test(test_Deterministic_k);
    // mu_run_test(test_PrivateKey_sign);
    // mu_run_test(test_PrivateKey_wif);

    // // //Signature tests
    // mu_run_test(test_Signature_der);
    // mu_run_test(test_Signature_parse);

    // // //Tx tests
    // mu_run_test(test_Tx_parse_version);
    // mu_run_test(test_Tx_parse_inputs);
    // mu_run_test(test_Tx_parse_outputs);
    // mu_run_test(test_Tx_parse_locktime);
    // mu_run_test(test_Tx_parse);
    // mu_run_test(test_TxOut_serialize);
    // mu_run_test(test_TxIn_serialize);
    // mu_run_test(test_Tx_serialize);
    mu_run_test(test_fee);
    // mu_run_test(test_http_get);
    // mu_run_test(test_tx_id);

    // // //Op tests
    // mu_run_test(test_encode_num);
    // mu_run_test(test_decode_num);
    // mu_run_test(test_op_hash160);
    // mu_run_test(test_op_checksig);

    // // //Script tests
    // mu_run_test(test_script_parse);
    // mu_run_test(test_script_serialize);
    // mu_run_test(test_script_add);
    // mu_run_test(test_script_evaluate);
    // mu_run_test(test_p2pk);
    // mu_run_test(test_p2pkh);

    // // //Helper tests
    // mu_run_test(test_encode_base58);
    // mu_run_test(test_little_endian_to_int);
    // mu_run_test(test_int_to_little_endian);
    // mu_run_test(test_little_endian_to_long);
    // mu_run_test(test_long_to_little_endian);
    // mu_run_test(test_print_formatted_bytes);
    // mu_run_test(test_read_varint);
    // mu_run_test(test_encode_varint);
    // mu_run_test(test_little_endian_to_big_endian);
    // mu_run_test(test_hash160);
    // mu_run_test(test_find_differences);
    // mu_run_test(test_hex_string_to_byte_array);

    // // //Create addresses
    // mu_run_test(generate_testnet_address);

    return 0;
}

int main(int argc, char **argv) {
    Initialize_prime();

    char *result = all_tests();
    if (result != 0) {
        printf("%s\n", result);
    } else {
        printf("ALL TESTS PASSED\n");
    }
    printf("Tests run: %d\n", tests_run);

    Free_prime();

    return result != 0;
}